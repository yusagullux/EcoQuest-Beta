<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="EcoQuest Dashboard - Track your eco-friendly missions, XP, and progress" />
    <meta name="keywords" content="ecoquest, dashboard, missions, eco-friendly, sustainability" />
    <meta name="author" content="EcoQuest" />
    <meta property="og:title" content="EcoQuest | Dashboard" />
    <meta property="og:description" content="Track your eco-friendly progress and complete daily missions" />
    <meta property="og:type" content="website" />
    <link rel="icon" type="image/png" href="../images/logo.png" />
    <title>EcoQuest | Dashboard</title>
    <link rel="stylesheet" href="../css/dashboard.css" />
    <link rel="stylesheet" href="../css/shop.css" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
</head>
<body>
    <header>
        <nav>
            <img src="../images/logo.png" alt="EcoQuest logo" onclick="window.location.href='dashboard.html'" style="cursor: pointer;" />
            <button class="mobile-menu-toggle" id="mobileMenuToggle" aria-label="Toggle mobile menu" aria-expanded="false">
                <span></span>
                <span></span>
                <span></span>
            </button>
            <ul id="mobileMenu">
                <li><a href="dashboard.html">Dashboard</a></li>
                <li><a href="team.html">Team</a></li>
                <li><a href="insights.html">Insights</a></li>
                <li><a href="shop.html">Shop</a></li>
                <li><a href="collection.html">Collection</a></li>
                <li><a href="profile.html">Profile</a></li>
                <li><a href="leaderboard.html">Leaderboard</a></li>
                <li><button id="logoutButtonMobile" class="logout-button-mobile">Sign Out</button></li>
            </ul>
            <button id="logoutButton" class="logout-button">Sign Out</button>
        </nav>
    </header>
    
    <main id="dashboard" role="main">
        <div class="user-info" role="region" aria-label="User Information">
            <h2>Welcome, <span id="userDisplayName">User</span>! <span id="userBadge" class="badge-display" aria-label="Current Badge"></span></h2>
            <div class="user-level-info">
                <span class="level-badge">Level <span id="userLevel">1</span></span>
                <p>Email: <span id="userEmail" class="user-email" aria-label="User Email">Loading...</span></p>
            </div>
        </div>

        <div class="user-stats" role="region" aria-label="User Statistics">
            <div class="stat-card" role="article" aria-label="Experience Points">
                <h3>XP</h3>
                <p class="stat-value" id="userXP" aria-live="polite">0</p>
                <div class="level-progress-container">
                    <div class="level-progress-bar" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" aria-label="Level Progress">
                        <div class="level-progress-fill" id="levelProgressFill"></div>
                    </div>
                    <div class="level-progress-text">
                        <span id="levelProgressCurrent">0</span> / <span id="levelProgressNext">100</span> XP
                    </div>
                </div>
            </div>
            <div class="stat-card" role="article" aria-label="EcoPoints">
                <h3>EcoPoints</h3>
                <p class="stat-value" id="ecoPoints" aria-live="polite">0</p>
                <p class="stat-subtitle">For Shop</p>
            </div>
            <div class="stat-card" role="article" aria-label="Carbon Reduction">
                <h3>üåç CO‚ÇÇ Reduced</h3>
                <p class="stat-value" id="totalCarbonReduced" aria-live="polite">0.0</p>
                <p class="stat-subtitle">kg CO‚ÇÇ</p>
            </div>
        </div>

        <div class="badge-showcase-card">
            <div class="badge-showcase-container">
                <div id="badgeShowcase" class="badge-showcase">
                    <div class="badge-placeholder">Loading badge...</div>
                </div>
                <div class="badge-info">
                    <h3 id="badgeName">-</h3>
                </div>
            </div>
        </div>

        <div class="dashboard-cards">
            <div class="dashboard-card">
                <div class="mission-header">
                    <h2>Today's Missions</h2>
                    <div id="countdownTimer" class="countdown-timer">
                        Loading...
                    </div>
                </div>
                <div class="mission-list" id="missionList">
                    <p>Loading missions...</p>
                </div>
            </div>
        </div>

        <div class="quest-progress-section">
            <div class="dashboard-card">
                <h2>Quest Progress Charts</h2>
                <div class="charts-container">
                    <div class="chart-wrapper">
                        <h3>Category Completion</h3>
                        <canvas id="categoryChart"></canvas>
                    </div>
                    <div class="chart-wrapper">
                        <h3>Carbon Footprint Reduction</h3>
                        <canvas id="carbonChart"></canvas>
                    </div>
                </div>
                <div class="category-progress-list" id="categoryProgressList">
                    
                </div>
            </div>
        </div>

    </main>

    <!-- Photo Lisamine(Pilti ei salvestata)-->
    <div id="photoUploadModal" class="photo-modal" style="display: none;">
        <div class="photo-modal-content">
            <div class="photo-modal-header">
                <h3>üì∏ Take Quest Proof Photo</h3>
                <button class="photo-modal-close" id="photoModalClose">&times;</button>
            </div>
            <div class="photo-modal-body">
                <p class="photo-instruction" id="photoInstruction">Please take a photo as proof that you completed this quest. The photo will not be stored.</p>
                <div class="photo-upload-area" id="photoUploadArea">
                    <input type="file" id="photoInput" accept="image/*" capture="environment" style="display: none;">
                    <label for="photoInput" class="photo-upload-label">
                        <span class="photo-upload-icon">üì∑</span>
                        <span class="photo-upload-text">Click to take a photo</span>
                    </label>
                    <div id="photoLoadingIndicator" class="photo-loading-indicator" style="display: none;">
                        <div class="photo-spinner"></div>
                        <p>Processing image...</p>
                    </div>
                    <div id="photoPreview" class="photo-preview" style="display: none;">
                        <img id="photoPreviewImg" src="" alt="Preview">
                        <button type="button" id="photoRemoveBtn" class="photo-remove-btn">Remove</button>
                    </div>
                </div>
                <div class="photo-modal-actions">
                    <button id="photoCancelBtn" class="photo-btn photo-btn-cancel">Cancel</button>
                    <button id="photoUploadBtn" class="photo-btn photo-btn-upload" disabled>Verify & Continue</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Team Admin -->
    <div id="teamManagerModal" class="team-modal" style="display: none;">
        <div class="team-modal-content">
            <div class="team-modal-header">
                <h3 id="teamModalTitle">Create a Team</h3>
                <button class="team-modal-close" id="teamModalCloseBtn">&times;</button>
            </div>
            <div class="team-modal-body">
                <p id="teamModalDescription">Name your squad so friends can recognize it.</p>
                <input type="text" id="teamModalInput" placeholder="Team Name" maxlength="40">
            </div>
            <div class="team-modal-actions">
                <button class="team-btn ghost" id="teamModalCancel">Cancel</button>
                <button class="team-btn" id="teamModalSubmit">Continue</button>
            </div>
        </div>
    </div>

    <!-- Team Mission Submit -->
    <div id="teamSubmissionModal" class="team-modal" style="display: none;">
        <div class="team-modal-content">
            <div class="team-modal-header">
                <h3 id="teamSubmissionTitle">Mission Update</h3>
                <button class="team-modal-close" id="teamSubmissionClose">&times;</button>
            </div>
            <div class="team-modal-body">
                <p class="team-muted" id="teamSubmissionDescription">Share a quick note on what your team accomplished.</p>
                <textarea id="teamSubmissionNote" rows="4" placeholder="Example: Collected 5 plastic bottles from the park."></textarea>
            </div>
            <div class="team-modal-actions">
                <button class="team-btn ghost" id="teamSubmissionCancel">Cancel</button>
                <button class="team-btn" id="teamSubmissionSubmit">Submit Proof</button>
            </div>
        </div>
    </div>

    <!-- Peegeldamine -->
    <div id="reflectionModal" class="team-modal" style="display: none;">
        <div class="team-modal-content">
            <div class="team-modal-header">
                <h3>Share a quick reflection</h3>
                <button class="team-modal-close" id="reflectionCloseBtn">&times;</button>
            </div>
            <div class="team-modal-body">
                <p class="team-muted">For private quests without photos, write at least 20 characters describing what you did.</p>
                <div id="reflectionList"></div>
            </div>
            <div class="team-modal-actions">
                <button class="team-btn ghost" id="reflectionCancelBtn">Cancel</button>
                <button class="team-btn" id="reflectionSubmitBtn">Save Notes</button>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>

    <script type="module">
        import { requireAuth } from "../js/auth-guard.js";
        import { logOut, getUserProfile, updateUserProfile, getAllUsers } from "../js/auth.js";
        import { getErrorMessage } from "../js/utils.js";
        import { 
            doc, 
            setDoc,
            getDoc,
            updateDoc,
            collection,
            addDoc,
            getDocs,
            query,
            where,
            limit,
            deleteDoc,
            deleteField,
            increment
        } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";
        import { db } from "../js/firebase-config.js";
        function getBadgeImageForLevel(level) {
            const badgeImages = {
                1: "../images/ecoquests-badges/cat-badge-removedbg.png", // Level 1 Helkuri Pilt
                2: "../images/ecoquests-badges/fox-badge-removedbg.png", // Level 2 Helkuri Pilt
                3: "../images/ecoquests-badges/rabbit-badge-removedbg.png", // Level 3 Helkuri Pilt
                4: "../images/ecoquests-badges/deer-badge-removedbg.png", // Level 4 Helkuri Pilt
                5: "../images/ecoquests-badges/wolf-badge-removedbg.png", // Level 5 Helkuri Pilt
                6: "../images/ecoquests-badges/bear-badge-removedbg.png", // Level 6 Helkuri Pilt
                7: "../images/ecoquests-badges/eagle-badge-removedbg.png", // Level 7 Helkuri Pilt
                8: "../images/ecoquests-badges/tiger-badge-removedbg.png", // Level 8 Helkuri Pilt
                9: "../images/ecoquests-badges/lion-badge-removedbg.png" // Level 9 Helkuri Pilt
            };
            return badgeImages[level] || badgeImages[1];
        }

        function getBadgeNameForLevel(level) {
            const badgeNames = {
                1: "Cat", // Level 1 Badge Name
                2: "Fox", // Level 2 Badge Name
                3: "Rabbit", // Level 3 Badge Name
                4: "Deer", // Level 4 Badge Name
                5: "Wolf", // Level 5 Badge Name
                6: "Bear", // Level 6 Badge Name
                7: "Eagle", // Level 7 Badge Name
                8: "Tiger", // Level 8 Badge Name
                9: "Lion" // Level 9 Badge Name
            };
            return badgeNames[level] || badgeNames[1];
        }

        // Helkuri kuvamise funktsioon, kontrollib taseme p√µhjal √µige pildi ja n√§itab seda
        function displayBadge(badgeElement, level, animate = false) {
            // kontrollib, et level oleks kehtiv (1-9), muidu v√µib tekkida bug
            const badgeImage = getBadgeImageForLevel(level);
            const badgeName = getBadgeNameForLevel(level);
            
            // eemaldab eelneva animatsiooni, et v√§ltida konflikte
            badgeElement.classList.remove('badge-unlock');
            // t√ºhjendab elemendi, et v√§ltida topeltkuvamist
            badgeElement.innerHTML = '';
            
            // loob uue pildi elemendi ja m√§√§rab selle atribuudid
            const img = document.createElement('img');
            img.src = badgeImage;
            img.alt = `${badgeName} Badge`;
            img.title = `${badgeName} Badge`;
            img.className = 'badge-image';
            
            badgeElement.appendChild(img);
            badgeElement.title = `${badgeName} Badge`;
            
            // animatsioon uue helkuri avamisel, void offsetWidth sunnib brauserit uuesti renderdama
            if (animate) {
                void badgeElement.offsetWidth; // tagab, et animatsioon t√∂√∂tab korrektselt
                badgeElement.classList.add('badge-unlock');
                setTimeout(() => {
                    badgeElement.classList.remove('badge-unlock');
                }, 2000);
            }
        }

        // meeskonna piirangud, need v√§√§rtused peavad olema kontrollitud enne misjonide lisamist
        const TEAM_LIMITS = {
            maxMembers: 8, // maksimaalne liikmete arv meeskonnas
            maxActiveMissions: 3, // maksimaalne aktiivsete missioonide arv korraga
            dailyMissionCap: 5, // maksimaalne missioonide arv p√§evas
            memberSubmissionCooldownMinutes: 60, // cooldown aeg sekundites enne j√§rgmist esitust
            minUniqueSubmitters: 2, // minimaalne erinevate esitajate arv enne kinnitamist
            requiredApprovals: 1 // vajalik kinnituste arv
        };

        const TEAM_REWARD_RULES = {
            ecoRatio: 0.6, 
            streakBonusPercent: 10, // Streak Bonus Protsent
            minReflectionLength: 20 
        };

        // Team Missionide Loetelu
        const TEAM_MISSION_LIBRARY = [
            {
                id: "team_recycle_15",
                title: "Recycle 15 Plastic Bottles",
                description: "Split the work and collect/recycle at least 15 plastic bottles as a team.",
                icon: "‚ôªÔ∏è",
                difficulty: "Easy",
                xpReward: 240,
                ecoReward: 140,
                requiredSubmissions: 3,
                category: "Recycling",
                cooldownHours: 12
            },
            {
                id: "team_cleanup_block",
                title: "Clean One Shared Area",
                description: "Pick a park block, beach spot or stairwell and leave it visibly better.",
                icon: "üßπ",
                difficulty: "Easy",
                xpReward: 260,
                ecoReward: 160,
                requiredSubmissions: 3,
                category: "Clean-Up",
                cooldownHours: 12
            },
            {
                id: "team_commute_swap",
                title: "Commute Sustainably Together",
                description: "On the same day, at least 3 teammates should bike, walk or take transit instead of a car trip.",
                icon: "üö∂",
                difficulty: "Medium",
                xpReward: 300,
                ecoReward: 180,
                requiredSubmissions: 3,
                category: "Transportation",
                cooldownHours: 18
            },
            {
                id: "team_water_saver",
                title: "Save 50 Liters of Water",
                description: "Each teammate shortens showers or reuses water to collectively save about 50 liters.",
                icon: "üíß",
                difficulty: "Medium",
                xpReward: 320,
                ecoReward: 190,
                requiredSubmissions: 3,
                category: "Water Saving",
                cooldownHours: 18
            },
            {
                id: "team_power_down",
                title: "Night Power Down",
                description: "Before sleep, unplug unused chargers/devices across at least 3 households.",
                icon: "üîå",
                difficulty: "Easy",
                xpReward: 220,
                ecoReward: 130,
                requiredSubmissions: 2,
                category: "Energy",
                cooldownHours: 10
            },
            {
                id: "team_micro_garden",
                title: "Plant or Care for 3 Greens",
                description: "Plant seeds, repot, or tend to three different plants as a joint effort.",
                icon: "üå±",
                difficulty: "Easy",
                xpReward: 210,
                ecoReward: 120,
                requiredSubmissions: 3,
                category: "Gardening",
                cooldownHours: 12
            }
        ];

        const NOTIFICATION_TEMPLATES = {
            teamReady: (missionTitle) => `Team mission "${missionTitle}" is ready for review.`,
            reminder: () => "Friendly nudge: complete at least one quest today ‚ú®",
            cooldown: (missionTitle) => `Cooldown active for "${missionTitle}". Try a different mission for now.`
        };

        // Helkuri N√§itamise Funktsioon 2
        function displayBadgeShowcase(level, animate = false) {
            const badgeImage = getBadgeImageForLevel(level);
            const badgeName = getBadgeNameForLevel(level);
            const showcaseElement = document.getElementById("badgeShowcase");
            const badgeNameElement = document.getElementById("badgeName");
            
            if (showcaseElement) {
                showcaseElement.classList.remove('badge-showcase-unlock');
                showcaseElement.innerHTML = '';
                
                const img = document.createElement('img');
                img.src = badgeImage;
                img.alt = `${badgeName} Badge`;
                img.className = 'badge-showcase-image';
                showcaseElement.appendChild(img);
                
                if (animate) {
                    void showcaseElement.offsetWidth;
                    showcaseElement.classList.add('badge-showcase-unlock');
                    setTimeout(() => {
                        showcaseElement.classList.remove('badge-showcase-unlock');
                    }, 2500);
                }
            }
            
            if (badgeNameElement) {
                badgeNameElement.textContent = badgeName;
            }
        }

        // Uue Badge(Helkuri) Avamise Funktsioon
        async function checkAndUnlockBadge(user, oldLevel, newLevel) {
            if (newLevel > oldLevel && newLevel <= 9) {
                const profileResult = await getUserProfile(user.uid);
                if (!profileResult.success) return;
                
                const profile = profileResult.data;
                const newBadge = getBadgeNameForLevel(newLevel);
                
                const badgeElement = document.getElementById("userBadge");
                if (badgeElement) {
                    displayBadge(badgeElement, newLevel, true);
                }
                
                displayBadgeShowcase(newLevel, false);
                
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        const badgeShowcaseCard = document.querySelector('.badge-showcase-card');
                        if (badgeShowcaseCard) {
                            const rect = badgeShowcaseCard.getBoundingClientRect();
                            const isVisible = rect.top >= 0 && rect.bottom <= window.innerHeight;
                            
                            if (!isVisible) {
                                badgeShowcaseCard.scrollIntoView({ 
                                    behavior: 'smooth', 
                                    block: 'center' 
                                });
                                setTimeout(() => {
                                    displayBadgeShowcase(newLevel, true);
                                }, 500);
                            } else {
                                setTimeout(() => {
                                    displayBadgeShowcase(newLevel, true);
                                }, 300);
                            }
                        } else {
                            displayBadgeShowcase(newLevel, true);
                        }
                    });
                });
                
                await updateUserProfile(user.uid, {
                    activeBadge: newBadge,
                    badges: [...new Set([...(profile.badges || []), newBadge])]
                });
            }
        }

        const LEVEL_MILESTONES = [
            0, // Level 1
            100, // Level 2
            250, // Level 3
            500, // Level 4
            1000, // Level 5
            2500, // Level 6
            5000, // Level 7
            10000, // Level 8
            50000 // Level 9
        ];

        function getXPRequiredForLevel(level) {
            if (level <= 1) return LEVEL_MILESTONES[1] - LEVEL_MILESTONES[0];
            if (level > LEVEL_MILESTONES.length) return Infinity;
            if (level === LEVEL_MILESTONES.length) return Infinity;
            return LEVEL_MILESTONES[level] - LEVEL_MILESTONES[level - 1];
        }

        function getTotalXPForLevel(level) {
            if (level <= 1) return 0;
            if (level > LEVEL_MILESTONES.length) return LEVEL_MILESTONES[LEVEL_MILESTONES.length - 1];
            return LEVEL_MILESTONES[level - 1];
        }

        // arvutab taseme XP p√µhjal, tagab et tase on alati 1-9 vahemikus
        function calculateLevel(xp) {
            // kui xp on negatiivne, tagastab 1
            if (xp < 0) return 1;
            for (let i = LEVEL_MILESTONES.length - 1; i >= 0; i--) {
                if (xp >= LEVEL_MILESTONES[i]) {
                    return i + 1;
                }
            }
            return 1; // vaikimisi tase 1, kui XP on v√§ga v√§ike
        }

        function getXPForNextLevel(xp, currentLevel) {
            const totalXPForCurrentLevel = getTotalXPForLevel(currentLevel);
            const xpInCurrentLevel = xp - totalXPForCurrentLevel;
            const requiredXP = getXPRequiredForLevel(currentLevel + 1);
            return Math.max(0, requiredXP - xpInCurrentLevel);
        }

        function getXPProgress(xp, currentLevel) {
            const totalXPForCurrentLevel = getTotalXPForLevel(currentLevel);
            const xpInCurrentLevel = xp - totalXPForCurrentLevel;
            const requiredXP = getXPRequiredForLevel(currentLevel + 1);
            const progress = requiredXP > 0 ? (xpInCurrentLevel / requiredXP) * 100 : 100;
            return {
                current: xpInCurrentLevel,
                required: requiredXP,
                percentage: Math.min(100, Math.max(0, progress))
            };
        }

        // arvutab EcoPoints XP ja taseme p√µhjal, kontrollib et tulemused oleksid alati positiivsed
        function calculateEcoPoints(xp, level, badgesCount = 0) {
            // kontrollib, et sisendid oleksid kehtivad
            if (xp < 0 || level < 1 || badgesCount < 0) {
                console.warn("Invalid input for calculateEcoPoints:", { xp, level, badgesCount });
                return 0;
            }
            
            let basePoints = 0;
            
            // mida k√µrgem tase, seda v√§hem EcoPoints XP kohta
            if (level <= 3) {
                basePoints = Math.floor(xp / 10);
            } else if (level <= 5) {
                basePoints = Math.floor(xp / 15);
            } else if (level <= 7) {
                basePoints = Math.floor(xp / 25);
            } else {
                basePoints = Math.floor(xp / 50);
            }
            
            // helkuri boonus, iga helkuri eest +10 punkti
            const badgeBonus = badgesCount * 10;
            
            return Math.max(0, basePoints + badgeBonus); // tagab, et tulemus on alati positiivne
        }

        function getTodayDateString() {
            const today = new Date();
            return today.toISOString().split('T')[0];
        }

        function getCurrentTimestamp() {
            return new Date().toISOString();
        }

        function getTimeUntilNextReset(lastResetTime) {
            const now = new Date().getTime();
            const lastResetTimestamp = new Date(lastResetTime).getTime();
            const hoursInMilliseconds = 24 * 60 * 60 * 1000;
            const nextResetTimestamp = lastResetTimestamp + hoursInMilliseconds;
            const timeRemaining = nextResetTimestamp - now;
            
            return Math.max(0, timeRemaining);
        }

        function formatTimeRemaining(milliseconds) {
            if (milliseconds <= 0) return "00:00:00";
            
            const secondsInMillisecond = 1000;
            const minutesInSecond = 60;
            const hoursInMinute = 60;
            
            const totalSeconds = Math.floor(milliseconds / secondsInMillisecond);
            const hours = Math.floor(totalSeconds / (hoursInMinute * minutesInSecond));
            const minutes = Math.floor((totalSeconds % (hoursInMinute * minutesInSecond)) / minutesInSecond);
            const seconds = totalSeconds % minutesInSecond;
            
            const formatNumber = (num) => String(num).padStart(2, '0');
            return `${formatNumber(hours)}:${formatNumber(minutes)}:${formatNumber(seconds)}`;
        }

        function shouldResetQuests(lastResetTime) {
            if (!lastResetTime) return true;
            const timeRemaining = getTimeUntilNextReset(lastResetTime);
            return timeRemaining <= 0;
        }

        let countdownInterval = null;

        function startCountdown(lastResetTime, onReset) {
            if (countdownInterval) {
                clearInterval(countdownInterval);
                countdownInterval = null;
            }
            
            if (!lastResetTime) {
                const countdownElement = document.getElementById("countdownTimer");
                if (countdownElement) {
                    countdownElement.textContent = "Calculating...";
                }
                return;
            }
            
            const updateCountdown = () => {
                const timeRemaining = getTimeUntilNextReset(lastResetTime);
                const countdownElement = document.getElementById("countdownTimer");
                
                if (!countdownElement) {
                    if (countdownInterval) {
                        clearInterval(countdownInterval);
                        countdownInterval = null;
                    }
                    return;
                }
                
                if (timeRemaining <= 0) {
                    countdownElement.textContent = "Resetting...";
                    if (countdownInterval) {
                        clearInterval(countdownInterval);
                        countdownInterval = null;
                    }
                    if (onReset) {
                        onReset();
                    }
                    return;
                }
                
                countdownElement.textContent = `Next reset: ${formatTimeRemaining(timeRemaining)}`;
            };
            
            updateCountdown();
            countdownInterval = setInterval(updateCountdown, 1000);
        }

        function stopCountdown() {
            if (countdownInterval) {
                clearInterval(countdownInterval);
                countdownInterval = null;
            }
        }

        // laadib missioonide loendi, tagab et vead ei katkesta rakendust
        async function loadQuests() {
            try {
                const response = await fetch('../quests.md');
                // kontrollib HTTP staatust enne teksti lugemist
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const text = await response.text();
                const quests = parseQuests(text);
                // tagab, et tagastatakse alati massiiv, isegi kui parsing eba√µnnestub
                return Array.isArray(quests) ? quests : [];
            } catch (error) {
                // logib vea, aga ei katkesta rakendust, tagastab t√ºhja massiivi
                console.error("Error loading quests:", error);
                return [];
            }
        }

        function parseQuests(markdown) {
            const quests = [];
            const lines = markdown.split('\n');
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line.startsWith('### ')) {
                    const titleMatch = line.match(/### (\d+)\. (.+)/);
                    if (titleMatch) {
                        let xp = 0;
                        let rewardText = "";
                        
                        for (let j = i + 1; j < Math.min(i + 5, lines.length); j++) {
                            const nextLine = lines[j].trim();
                            
                            const xpMatch = nextLine.match(/\*\*XP Score:\*\* (\d+)\s*XP/);
                            if (xpMatch) {
                                xp = parseInt(xpMatch[1]);
                            }
                            
                            const rewardMatch = nextLine.match(/\*\*Reward:\*\* (.+)/);
                            if (rewardMatch) {
                                rewardText = rewardMatch[1].trim();
                            }
                        }
                        
                        if (xp > 0) {
                            const questId = titleMatch[1];
                            const questMapping = QUEST_ID_MAPPING[questId];
                            quests.push({
                                id: questId,
                                title: titleMatch[2].trim(),
                                reward: rewardText || `${xp} XP`,
                                xp: xp,
                                category: questMapping?.category || "unknown",
                                categoryName: questMapping?.categoryName || "Unknown",
                                categoryIcon: questMapping?.categoryIcon || "üìã",
                                categoryColor: questMapping?.categoryColor || "#999999"
                            });
                        }
                    }
                }
            }

            return quests;
        }

        function getQuestBonusMultiplier(timesCompleted) {
            const BASE_MULTIPLIER = 1.0;
            const BONUS_PER_COMPLETION = 0.2;
            const MAX_MULTIPLIER = 3.0;
            
            if (timesCompleted <= 0) return BASE_MULTIPLIER;
            const calculatedBonus = BASE_MULTIPLIER + (timesCompleted * BONUS_PER_COMPLETION);
            return Math.min(calculatedBonus, MAX_MULTIPLIER);
        }

        let pendingQuestCompletion = null;
        let currentQuestIndex = 0;
        let verifiedPhotos = {};
        let questReflectionNotes = {};
        let reflectionResolver = null;
        let reflectionPendingIds = [];
        let currentProfileData = null;
        
        // Privaatsete Questide Loetelu(privaatne)
        const QUESTS_WITHOUT_PHOTO = [
            'water_1',      // Turn off water while brushing (privaatne)
            'water_2',      // Reduce shower time by 2 minutes (privaatne)
            'energy_5',     // Turn off electronics at night (privaatne)
            'energy_3',     // Charge phone only when needed (privaatne)
            'sustainable_4' // Unplug unused chargers (privaatne)
        ];
        let cachedQuestsDataForPhoto = null;
        
        // First check manually marked IDs
        async function questRequiresPhoto(questId) {
            const mappedQuest = QUEST_ID_MAPPING[questId];
            const jsonQuestIds = mappedQuest?.jsonIds || [];
            
            for (const jsonId of jsonQuestIds) {
                if (QUESTS_WITHOUT_PHOTO.includes(jsonId)) {
                    return false;
                }
            }
            
            if (!cachedQuestsDataForPhoto) {
                cachedQuestsDataForPhoto = await loadQuestsData();
            }
            
            if (cachedQuestsDataForPhoto && cachedQuestsDataForPhoto.categories) {
                for (const jsonId of jsonQuestIds) {
                    for (const category of cachedQuestsDataForPhoto.categories) {
                        const quest = category.quests?.find(q => q.id === jsonId);
                        if (quest) {
                            if (quest.hasOwnProperty('requiresPhoto')) {
                                return quest.requiresPhoto === true;
                            }
                        }
                    }
                }
            }
            
            return true;
        }

        function getQuestTitleById(questId) {
            const quests = window.currentQuests || [];
            const quest = quests.find(q => q.id === questId);
            return quest ? quest.title : questId;
        }

        function escapeHtml(value = "") {
            const div = document.createElement('div');
            div.textContent = value;
            return div.innerHTML;
        }

        function buildReflectionInputs(questIds) {
            const container = document.getElementById('reflectionList');
            if (!container) return;
            container.innerHTML = '';
            questIds.forEach((questId) => {
                const wrapper = document.createElement('div');
                wrapper.className = 'reflection-item';
                wrapper.innerHTML = `
                    <label for="reflection-${questId}">${getQuestTitleById(questId)}</label>
                    <textarea id="reflection-${questId}" data-quest-id="${questId}" rows="3" placeholder="Describe what you did..." minlength="${TEAM_REWARD_RULES.minReflectionLength}"></textarea>
                `;
                container.appendChild(wrapper);
            });
        }

        function openReflectionModal(questIds) {
            return new Promise((resolve) => {
                const modal = document.getElementById('reflectionModal');
                if (!modal) {
                    resolve(true);
                    return;
                }
                reflectionResolver = resolve;
                reflectionPendingIds = questIds;
                buildReflectionInputs(questIds);
                modal.style.display = 'flex';
                document.body.classList.add('modal-open');
            });
        }

        function closeReflectionModal(confirmed = false) {
            const modal = document.getElementById('reflectionModal');
            if (modal) {
                modal.style.display = 'none';
            }
            document.body.classList.remove('modal-open');
            const resolver = reflectionResolver;
            reflectionResolver = null;
            reflectionPendingIds = [];
            if (resolver) {
                resolver(confirmed);
            }
        }

        async function ensureReflectionNotes(questIds) {
            const pending = questIds.filter(id => !questReflectionNotes[id]);
            if (pending.length === 0) {
                return true;
            }
            return await openReflectionModal(pending);
        }

        function initializeReflectionModal() {
            const submitBtn = document.getElementById('reflectionSubmitBtn');
            const cancelBtn = document.getElementById('reflectionCancelBtn');
            const closeBtn = document.getElementById('reflectionCloseBtn');
            const modal = document.getElementById('reflectionModal');
            
            const handleClose = () => closeReflectionModal(false);
            
            if (cancelBtn) {
                cancelBtn.addEventListener('click', handleClose);
            }
            if (closeBtn) {
                closeBtn.addEventListener('click', handleClose);
            }
            if (modal) {
                modal.addEventListener('click', (event) => {
                    if (event.target === modal) {
                        handleClose();
                    }
                });
            }
            if (submitBtn) {
                submitBtn.addEventListener('click', () => {
                    const container = document.getElementById('reflectionList');
                    if (!container) {
                        closeReflectionModal(true);
                        return;
                    }
                    const inputs = Array.from(container.querySelectorAll('textarea[data-quest-id]'));
                    if (inputs.length === 0) {
                        closeReflectionModal(true);
                        return;
                    }
                    for (const input of inputs) {
                        const questId = input.dataset.questId;
                        const value = (input.value || '').trim();
                        if (!questId) {
                            continue;
                        }
                        if (value.length < TEAM_REWARD_RULES.minReflectionLength) {
                            alert(`Please write at least ${TEAM_REWARD_RULES.minReflectionLength} characters for "${getQuestTitleById(questId)}".`);
                            return;
                        }
                    }
                    inputs.forEach((input) => {
                        const questId = input.dataset.questId;
                        questReflectionNotes[questId] = input.value.trim();
                    });
                    closeReflectionModal(true);
                });
            }
        }

        async function logQuestAudits(entries = []) {
            if (!Array.isArray(entries) || entries.length === 0) {
                return;
            }
            try {
                const logsCollection = collection(db, "missionLogs");
                const timestamp = new Date().toISOString();
                const operations = entries.map(entry => addDoc(logsCollection, {
                    userId: entry.userId,
                    questId: entry.questId,
                    questTitle: entry.questTitle,
                    xpEarned: entry.xpEarned || 0,
                    ecoEarned: entry.ecoEarned || 0,
                    reflection: entry.reflection || null,
                    type: entry.type || "solo",
                    teamId: entry.teamId || null,
                    teamMissionId: entry.teamMissionId || null,
                    createdAt: timestamp
                }));
                await Promise.all(operations);
            } catch (error) {
                console.error("Failed to log mission audits:", error);
            }
        }

        function normalizeTeamCode(code = "") {
            return (code || "").toUpperCase().replace(/[^A-Z0-9]/g, '').slice(0, 6);
        }

        async function teamJoinCodeExists(code) {
            try {
                const teamsRef = collection(db, "teams");
                const q = query(teamsRef, where("joinCode", "==", code), limit(1));
                const snapshot = await getDocs(q);
                return !snapshot.empty;
            } catch (error) {
                console.error("Error checking team code:", error);
                return false;
            }
        }

        async function generateUniqueTeamCode() {
            const alphabet = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789";
            let attempts = 0;
            while (attempts < 8) {
                let candidate = "";
                for (let i = 0; i < 6; i++) {
                    candidate += alphabet[Math.floor(Math.random() * alphabet.length)];
                }
                const exists = await teamJoinCodeExists(candidate);
                if (!exists) {
                    return candidate;
                }
                attempts++;
            }
            throw new Error("Unable to generate unique team code. Please try again.");
        }

        async function fetchTeamDocument(teamId) {
            if (!teamId) return null;
            try {
                const teamRef = doc(db, "teams", teamId);
                const snapshot = await getDoc(teamRef);
                if (!snapshot.exists()) {
                    return null;
                }
                return { id: snapshot.id, ...snapshot.data() };
            } catch (error) {
                console.error("Error fetching team:", error);
                return null;
            }
        }

        async function fetchTeamMissions(teamId) {
            if (!teamId) return [];
            try {
                const missionsRef = collection(db, "teams", teamId, "activeMissions");
                const snapshot = await getDocs(missionsRef);
                return snapshot.docs.map(docSnap => ({
                    id: docSnap.id,
                    ...docSnap.data()
                }));
            } catch (error) {
                console.error("Error fetching team missions:", error);
                return [];
            }
        }

        function pushNotification(message, tone = "info") {
            const entry = {
                id: `${Date.now()}-${Math.random().toString(16).slice(2)}`,
                message,
                tone,
                createdAt: new Date()
            };
            notificationQueue.unshift(entry);
            notificationQueue = notificationQueue.slice(0, 6);
            renderNotificationFeed();
        }

        function renderNotificationFeed() {
            const feed = document.getElementById('notificationFeed');
            if (!feed) return;
            if (!notificationQueue.length) {
                feed.innerHTML = `<p class="team-muted">No notifications yet. We'll list mission deadlines and streak tips here.</p>`;
                return;
            }
            feed.innerHTML = notificationQueue.map(item => `
                <div class="notification-item ${item.tone}">
                    <div>
                        <p>${escapeHtml(item.message)}</p>
                        <span class="notification-time">${item.createdAt.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</span>
                    </div>
                </div>
            `).join('');
        }

        function renderTeamEmptyState() {
            const emptyState = document.getElementById('teamEmptyState');
            const details = document.getElementById('teamDetails');
            const leaveBtn = document.getElementById('teamLeaveBtn');
            if (emptyState) emptyState.style.display = 'block';
            if (details) details.style.display = 'none';
            if (leaveBtn) leaveBtn.style.display = 'none';
        }

        function renderTeamOverview(profile) {
            const emptyState = document.getElementById('teamEmptyState');
            const details = document.getElementById('teamDetails');
            const leaveBtn = document.getElementById('teamLeaveBtn');
            if (!currentTeamData) {
                renderTeamEmptyState();
                return;
            }
            if (emptyState) emptyState.style.display = 'none';
            if (details) details.style.display = 'block';
            if (leaveBtn) leaveBtn.style.display = 'inline-flex';
            
            const role = profile.teamRole || (currentTeamData.leaderId === currentUser.uid ? "leader" : "member");
            if (document.getElementById('teamNameDisplay')) {
                document.getElementById('teamNameDisplay').textContent = currentTeamData.name || "Unnamed Team";
            }
            if (document.getElementById('teamCodeDisplay')) {
                document.getElementById('teamCodeDisplay').textContent = `Code: ${currentTeamData.joinCode || "-"}`;
            }
            if (document.getElementById('teamRoleDisplay')) {
                document.getElementById('teamRoleDisplay').textContent = `Role: ${role}`;
            }
            if (document.getElementById('teamXpStat')) {
                document.getElementById('teamXpStat').textContent = currentTeamData.stats?.xpEarned || 0;
            }
            if (document.getElementById('teamEcoStat')) {
                document.getElementById('teamEcoStat').textContent = currentTeamData.stats?.ecoEarned || 0;
            }
            if (document.getElementById('teamMissionStat')) {
                document.getElementById('teamMissionStat').textContent = currentTeamData.stats?.missionsCompleted || 0;
            }
            if (document.getElementById('teamMemberCount')) {
                const memberCount = currentTeamData.members ? Object.keys(currentTeamData.members).length : 0;
                document.getElementById('teamMemberCount').textContent = memberCount;
            }
            renderTeamMembers();
        }

        function renderTeamMembers() {
            const list = document.getElementById('teamMembersList');
            if (!list) return;
            if (!currentTeamData || !currentTeamData.members) {
                list.innerHTML = '<li class="team-muted">No members yet.</li>';
                return;
            }
            const members = Object.entries(currentTeamData.members).map(([id, info]) => ({
                id,
                ...info
            }));
            members.sort((a, b) => {
                if (a.role === b.role) return (a.displayName || '').localeCompare(b.displayName || '');
                if (a.role === 'leader') return -1;
                if (b.role === 'leader') return 1;
                if (a.role === 'co_leader') return -1;
                if (b.role === 'co_leader') return 1;
                return 0;
            });
            list.innerHTML = members.map(member => `
                <li class="team-member ${member.id === currentUser.uid ? 'self' : ''}">
                    <span>${escapeHtml(member.displayName || 'Member')}</span>
                    <span class="team-role">${escapeHtml(member.role || 'member')}</span>
                </li>
            `).join('');
        }

        function renderTeamMissionLibrary(profile) {
            const library = document.getElementById('teamMissionLibrary');
            if (!library) return;
            if (!profile.teamId) {
                library.innerHTML = `<p class="team-muted">Join a team to unlock collaborative missions.</p>`;
                return;
            }
            library.innerHTML = TEAM_MISSION_LIBRARY.map(mission => {
                const disabled = !profile.teamId || (profile.teamRole !== 'leader' && profile.teamRole !== 'co_leader');
                return `
                    <div class="team-mission-template">
                        <div>
                            <h4>${mission.icon} ${escapeHtml(mission.title)}</h4>
                            <p>${escapeHtml(mission.description)}</p>
                            <div class="mission-meta">
                                <span>Difficulty: ${mission.difficulty}</span>
                                <span>Reward: +${mission.xpReward} XP / +${mission.ecoReward} Eco</span>
                                <span>Need ${mission.requiredSubmissions} teammates</span>
                            </div>
                        </div>
                        <button 
                            class="team-btn ${disabled ? 'ghost' : ''}" 
                            data-team-action="assign" 
                            data-template-id="${mission.id}"
                            ${disabled ? 'disabled' : ''}>
                            Assign
                        </button>
                    </div>
                `;
            }).join('');
        }

        function renderActiveTeamMissions(profile) {
            const container = document.getElementById('activeTeamMissions');
            const hint = document.getElementById('teamMissionHint');
            if (hint) {
                hint.textContent = profile.teamId
                    ? `Active missions: ${activeTeamMissions.length}/${TEAM_LIMITS.maxActiveMissions}`
                    : "Complete cooperative tasks for extra XP.";
            }
            if (!container) return;
            if (!profile.teamId) {
                container.innerHTML = `<p class="team-muted">Join or create a team to unlock collaborative missions.</p>`;
                return;
            }
            if (!activeTeamMissions || activeTeamMissions.length === 0) {
                container.innerHTML = `<p class="team-muted">No active missions yet. Assign one to get started.</p>`;
                return;
            }
            container.innerHTML = activeTeamMissions.map(mission => {
                const submissions = mission.submissions || [];
                const requirement = Math.max(1, mission.requiredSubmissions || 1);
                const progress = Math.min(100, Math.round((submissions.length / requirement) * 100));
                const ready = submissions.length >= requirement;
                const alreadySubmitted = submissions.some(s => s.userId === currentUser.uid);
                const canApprove = ready && (profile.teamRole === 'leader' || profile.teamRole === 'co_leader');
                const canSubmit = !alreadySubmitted && !ready;
                return `
                    <div class="team-mission-card ${ready ? 'ready' : ''}">
                        <div class="team-mission-head">
                            <div>
                                <h4>${mission.icon || 'üåø'} ${escapeHtml(mission.title)}</h4>
                                <p>${escapeHtml(mission.description || '')}</p>
                            </div>
                            <div class="team-mission-rewards">
                                <span>+${mission.xpReward} XP</span>
                                <span>+${mission.ecoReward} Eco</span>
                            </div>
                        </div>
                        <div class="team-mission-progress">
                            <div class="progress-bar">
                                <div class="progress-fill" style="width:${progress}%;"></div>
                            </div>
                            <span>${submissions.length}/${mission.requiredSubmissions} submissions</span>
                        </div>
                        <div class="team-mission-actions">
                            <button 
                                class="team-btn ${canSubmit ? '' : 'ghost'}" 
                                data-team-action="submit" 
                                data-mission-id="${mission.id}"
                                ${canSubmit ? '' : 'disabled'}>
                                ${alreadySubmitted ? "Submitted" : "Submit Progress"}
                            </button>
                            <button 
                                class="team-btn secondary" 
                                data-team-action="review" 
                                data-mission-id="${mission.id}"
                                ${canApprove ? '' : 'disabled'}>
                                ${ready ? "Approve & Reward" : "Waiting for team"}
                            </button>
                        </div>
                        <div class="team-mission-submissions">
                            ${submissions.map(sub => `
                                <div class="submission-chip">
                                    <strong>${escapeHtml(sub.displayName || 'Member')}</strong>
                                    <p>${escapeHtml(sub.note || 'Submitted proof')}</p>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            }).join('');
        }

        function openTeamManagerModal(mode) {
            const modal = document.getElementById('teamManagerModal');
            const title = document.getElementById('teamModalTitle');
            const description = document.getElementById('teamModalDescription');
            const input = document.getElementById('teamModalInput');
            if (!modal || !title || !description || !input) return;
            teamModalMode = mode;
            input.value = '';
            if (mode === 'create') {
                title.textContent = "Create a Team";
                description.textContent = "Name your squad so friends can recognize it.";
                input.placeholder = "Example: Green Guardians";
            } else {
                title.textContent = "Join a Team";
                description.textContent = "Enter the 6-character invite code shared by your teammate.";
                input.placeholder = "Example: ECO123";
            }
            modal.style.display = 'flex';
            document.body.classList.add('modal-open');
            input.focus();
        }

        function closeTeamManagerModal() {
            const modal = document.getElementById('teamManagerModal');
            if (modal) {
                modal.style.display = 'none';
            }
            document.body.classList.remove('modal-open');
            teamModalMode = null;
        }

        function openTeamSubmissionModal(missionId) {
            if (!missionId) return;
            const modal = document.getElementById('teamSubmissionModal');
            const title = document.getElementById('teamSubmissionTitle');
            const note = document.getElementById('teamSubmissionNote');
            if (!modal || !title || !note) return;
            const mission = activeTeamMissions.find(m => m.id === missionId);
            teamSubmissionContext = missionId;
            title.textContent = mission ? `Update: ${mission.title}` : "Mission Update";
            note.value = "";
            modal.style.display = 'flex';
            document.body.classList.add('modal-open');
            note.focus();
        }

        function closeTeamSubmissionModal() {
            const modal = document.getElementById('teamSubmissionModal');
            if (modal) {
                modal.style.display = 'none';
            }
            document.body.classList.remove('modal-open');
            teamSubmissionContext = null;
        }

        async function refreshTeamData(profile, notify = false) {
            if (!profile.teamId) {
                currentTeamData = null;
                activeTeamMissions = [];
                renderTeamEmptyState();
                renderActiveTeamMissions(profile);
                await renderTeamLeaderboard(profile);
                return;
            }
            currentTeamData = await fetchTeamDocument(profile.teamId);
            activeTeamMissions = await fetchTeamMissions(profile.teamId);
            renderTeamOverview(profile);
            renderTeamMissionLibrary(profile);
            renderActiveTeamMissions(profile);
            await renderTeamLeaderboard(profile);
            if (notify && currentTeamData) {
                pushNotification(`Joined team "${currentTeamData.name}".`, "success");
            }
        }

        async function createTeamDocument(profile, teamName) {
            const trimmed = (teamName || "").trim();
            if (trimmed.length < 3) {
                throw new Error("Team name must have at least 3 characters.");
            }
            const joinCode = await generateUniqueTeamCode();
            const teamRef = doc(collection(db, "teams"));
            const timestamp = new Date().toISOString();
            const members = {};
            members[currentUser.uid] = {
                displayName: profile.displayName || profile.email || "Member",
                role: "leader",
                joinedAt: timestamp
            };
            await setDoc(teamRef, {
                name: trimmed,
                joinCode,
                leaderId: currentUser.uid,
                members,
                stats: {
                    missionsCompleted: 0,
                    xpEarned: 0,
                    ecoEarned: 0,
                    approvals: 0
                },
                dailyMissionCounter: {},
                createdAt: timestamp,
                activeMissionCount: 0
            });
            await updateUserProfile(currentUser.uid, { teamId: teamRef.id, teamRole: "leader" });
            return teamRef.id;
        }

        async function joinTeamByCode(profile, teamCode) {
            const normalized = normalizeTeamCode(teamCode);
            if (!normalized || normalized.length < 6) {
                throw new Error("Please enter a valid 6-character code.");
            }
            const teamsRef = collection(db, "teams");
            const q = query(teamsRef, where("joinCode", "==", normalized), limit(1));
            const snapshot = await getDocs(q);
            if (snapshot.empty) {
                throw new Error("No team found with that code.");
            }
            const teamDoc = snapshot.docs[0];
            const data = teamDoc.data();
            const members = data.members || {};
            if (members[currentUser.uid]) {
                throw new Error("You are already part of this team.");
            }
            if (Object.keys(members).length >= TEAM_LIMITS.maxMembers) {
                throw new Error("This team reached the member limit.");
            }
            const joinedAt = new Date().toISOString();
            await updateDoc(teamDoc.ref, {
                [`members.${currentUser.uid}`]: {
                    displayName: profile.displayName || profile.email || "Member",
                    role: "member",
                    joinedAt
                }
            });
            await updateUserProfile(currentUser.uid, { teamId: teamDoc.id, teamRole: "member" });
            return teamDoc.id;
        }

        async function leaveCurrentTeam(profile) {
            if (!profile.teamId) return;
            const teamRef = doc(db, "teams", profile.teamId);
            const snapshot = await getDoc(teamRef);
            if (!snapshot.exists()) {
                await updateUserProfile(currentUser.uid, { teamId: null, teamRole: null });
                return;
            }
            const data = snapshot.data();
            const members = data.members || {};
            if (!members[currentUser.uid]) {
                await updateUserProfile(currentUser.uid, { teamId: null, teamRole: null });
                return;
            }
            const remainingMembers = Object.keys(members).filter(uid => uid !== currentUser.uid);
            if (remainingMembers.length === 0) {
                await deleteDoc(teamRef);
            } else {
                const updates = {
                    [`members.${currentUser.uid}`]: deleteField()
                };
                if (data.leaderId === currentUser.uid) {
                    const newLeaderId = remainingMembers[0];
                    updates.leaderId = newLeaderId;
                    updates[`members.${newLeaderId}.role`] = "leader";
                }
                await updateDoc(teamRef, updates);
            }
            await updateUserProfile(currentUser.uid, { teamId: null, teamRole: null });
            currentTeamData = null;
            activeTeamMissions = [];
        }

        async function assignTeamMission(profile, templateId) {
            if (!profile.teamId) {
                throw new Error("Join a team first.");
            }
            if (!currentTeamData) {
                await refreshTeamData(profile);
            }
            if (profile.teamRole !== 'leader' && profile.teamRole !== 'co_leader') {
                throw new Error("Only leaders can assign new missions.");
            }
            const template = TEAM_MISSION_LIBRARY.find(m => m.id === templateId);
            if (!template) {
                throw new Error("Mission template not found.");
            }
            if (activeTeamMissions.length >= TEAM_LIMITS.maxActiveMissions) {
                throw new Error("Maximum active missions reached.");
            }
            const todayKey = getTodayDateString();
            const teamDailyCount = currentTeamData?.dailyMissionCounter?.[todayKey] || 0;
            if (teamDailyCount >= TEAM_LIMITS.dailyMissionCap) {
                throw new Error("Team reached today's mission limit. Try again tomorrow.");
            }
            await addDoc(collection(db, "teams", profile.teamId, "activeMissions"), {
                missionTemplateId: template.id,
                title: template.title,
                description: template.description,
                icon: template.icon,
                difficulty: template.difficulty,
                xpReward: template.xpReward,
                ecoReward: template.ecoReward,
                requiredSubmissions: template.requiredSubmissions,
                status: "active",
                submissions: [],
                startedBy: currentUser.uid,
                startedAt: new Date().toISOString()
            });
            await updateDoc(doc(db, "teams", profile.teamId), {
                activeMissionCount: increment(1)
            });
            await refreshTeamData(profile);
            pushNotification(`Mission "${template.title}" assigned to your team.`, "success");
        }

        async function submitTeamMissionProgress(profile, missionId, note) {
            if (!profile.teamId) {
                throw new Error("Join a team first.");
            }
            if (!currentTeamData) {
                await refreshTeamData(profile);
            }
            const trimmed = (note || "").trim();
            if (trimmed.length < TEAM_REWARD_RULES.minReflectionLength) {
                throw new Error(`Please describe your effort in at least ${TEAM_REWARD_RULES.minReflectionLength} characters.`);
            }
            const missionRef = doc(db, "teams", profile.teamId, "activeMissions", missionId);
            const snapshot = await getDoc(missionRef);
            if (!snapshot.exists()) {
                throw new Error("Mission not found.");
            }
            const mission = snapshot.data();
            const submissions = mission.submissions || [];
            if (submissions.some(sub => sub.userId === currentUser.uid)) {
                throw new Error("You already submitted proof for this mission.");
            }
            const newSubmissions = [
                ...submissions,
                {
                    userId: currentUser.uid,
                    displayName: profile.displayName || profile.email || "Member",
                    note: trimmed,
                    submittedAt: new Date().toISOString()
                }
            ];
            const ready = newSubmissions.length >= mission.requiredSubmissions;
            await updateDoc(missionRef, {
                submissions: newSubmissions,
                status: ready ? "ready_for_review" : "active",
                lastUpdatedAt: new Date().toISOString()
            });
            activeTeamMissions = activeTeamMissions.map(m => 
                m.id === missionId ? { ...m, submissions: newSubmissions, status: ready ? "ready_for_review" : "active" } : m
            );
            renderActiveTeamMissions(profile);
            if (ready) {
                pushNotification(NOTIFICATION_TEMPLATES.teamReady(mission.title), "team");
            }
        }

        async function approveTeamMission(profile, missionId) {
            if (!profile.teamId) {
                throw new Error("No team linked.");
            }
            if (!currentTeamData) {
                await refreshTeamData(profile);
            }
            if (profile.teamRole !== 'leader' && profile.teamRole !== 'co_leader') {
                throw new Error("Only leaders can approve missions.");
            }
            const missionRef = doc(db, "teams", profile.teamId, "activeMissions", missionId);
            const snapshot = await getDoc(missionRef);
            if (!snapshot.exists()) {
                throw new Error("Mission not found.");
            }
            const mission = snapshot.data();
            const submissions = mission.submissions || [];
            if (submissions.length < TEAM_LIMITS.minUniqueSubmitters) {
                throw new Error("Need more unique submissions before approval.");
            }
            const participants = submissions;
            const xpPerUser = Math.max(10, Math.floor(mission.xpReward / participants.length));
            const ecoPerUser = Math.max(5, Math.floor(mission.ecoReward / participants.length));
            
            for (const participant of participants) {
                try {
                    const profileResult = await getUserProfile(participant.userId);
                    if (!profileResult.success) continue;
                    const participantProfile = profileResult.data;
                    const newXP = (participantProfile.xp || 0) + xpPerUser;
                    const newLevel = calculateLevel(newXP);
                    const newEco = (participantProfile.ecoPoints || 0) + ecoPerUser;
                    const teamStats = participantProfile.teamStats || { missionsCompleted: 0, xpEarned: 0, ecoEarned: 0, approvalsGiven: 0 };
                    await updateUserProfile(participant.userId, {
                        xp: newXP,
                        ecoPoints: newEco,
                        level: newLevel,
                        missionsCompleted: (participantProfile.missionsCompleted || 0) + 1,
                        teamStats: {
                            missionsCompleted: (teamStats.missionsCompleted || 0) + 1,
                            xpEarned: (teamStats.xpEarned || 0) + xpPerUser,
                            ecoEarned: (teamStats.ecoEarned || 0) + ecoPerUser,
                            approvalsGiven: teamStats.approvalsGiven || 0
                        }
                    });
                } catch (error) {
                    console.error("Error rewarding participant:", error);
                }
            }
            
            await updateDoc(doc(db, "teams", profile.teamId), {
                "stats.missionsCompleted": increment(1),
                "stats.xpEarned": increment(mission.xpReward || 0),
                "stats.ecoEarned": increment(mission.ecoReward || 0),
                "stats.approvals": increment(1),
                activeMissionCount: increment(-1),
                [`dailyMissionCounter.${getTodayDateString()}`]: increment(1),
                lastMissionCompletedAt: new Date().toISOString()
            });
            
            if (currentTeamData && currentTeamData.id === profile.teamId) {
                currentTeamData.stats = {
                    missionsCompleted: (currentTeamData.stats?.missionsCompleted || 0) + 1,
                    xpEarned: (currentTeamData.stats?.xpEarned || 0) + (mission.xpReward || 0),
                    ecoEarned: (currentTeamData.stats?.ecoEarned || 0) + (mission.ecoReward || 0),
                    approvals: (currentTeamData.stats?.approvals || 0) + 1
                };
                const todayKey = getTodayDateString();
                currentTeamData.dailyMissionCounter = currentTeamData.dailyMissionCounter || {};
                currentTeamData.dailyMissionCounter[todayKey] = (currentTeamData.dailyMissionCounter[todayKey] || 0) + 1;
            }
            
            await logQuestAudits(participants.map(participant => ({
                userId: participant.userId,
                questId: mission.missionTemplateId || missionId,
                questTitle: mission.title,
                reflection: participant.note || null,
                xpEarned: xpPerUser,
                ecoEarned: ecoPerUser,
                type: "team",
                teamId: profile.teamId,
                teamMissionId: missionId
            })));
            
            try {
                await addDoc(collection(db, "teams", profile.teamId, "missionLogs"), {
                    missionId,
                    title: mission.title,
                    completedAt: new Date().toISOString(),
                    rewardedXp: mission.xpReward || 0,
                    rewardedEco: mission.ecoReward || 0,
                    participants: participants.map(p => ({ userId: p.userId, displayName: p.displayName || "Member" }))
                });
            } catch (error) {
                console.warn("Unable to write team mission log:", error);
            }
            
            if (profile.teamStats) {
                await updateUserProfile(currentUser.uid, {
                    teamStats: {
                        ...profile.teamStats,
                        approvalsGiven: (profile.teamStats.approvalsGiven || 0) + 1,
                        missionsCompleted: profile.teamStats.missionsCompleted || 0,
                        xpEarned: profile.teamStats.xpEarned || 0,
                        ecoEarned: profile.teamStats.ecoEarned || 0
                    }
                });
                profile.teamStats.approvalsGiven = (profile.teamStats.approvalsGiven || 0) + 1;
            }
            
            await deleteDoc(missionRef);
            activeTeamMissions = activeTeamMissions.filter(m => m.id !== missionId);
            await refreshTeamData(profile);
            renderActiveTeamMissions(profile);
            pushNotification(`Approved "${mission.title}". Rewards sent to teammates.`, "success");
        }

        function bindTeamUI(profile) {
            const createButtons = [
                document.getElementById('teamCreateBtn'),
                document.getElementById('teamQuickCreateBtn')
            ];
            createButtons.forEach(btn => {
                if (!btn) return;
                btn.addEventListener('click', () => openTeamManagerModal('create'));
            });
            
            const joinButtons = [
                document.getElementById('teamJoinBtn'),
                document.getElementById('teamQuickJoinBtn')
            ];
            joinButtons.forEach(btn => {
                if (!btn) return;
                btn.addEventListener('click', () => openTeamManagerModal('join'));
            });
            
            const leaveBtn = document.getElementById('teamLeaveBtn');
            if (leaveBtn) {
                leaveBtn.addEventListener('click', async () => {
                    if (!confirm("Leave the current team?")) return;
                    try {
                        await leaveCurrentTeam(profile);
                        profile.teamId = null;
                        profile.teamRole = null;
                        await refreshTeamData(profile);
                        pushNotification("You left the team.", "warning");
                    } catch (error) {
                        alert(error.message || "Unable to leave the team right now.");
                    }
                });
            }
            
            const copyBtn = document.getElementById('teamCopyCodeBtn');
            if (copyBtn) {
                copyBtn.addEventListener('click', async () => {
                    if (!currentTeamData?.joinCode) {
                        alert("No code to copy.");
                        return;
                    }
                    try {
                        await navigator.clipboard.writeText(currentTeamData.joinCode);
                        pushNotification("Team code copied to clipboard.", "success");
                    } catch {
                        alert("Unable to copy automatically. Code: " + currentTeamData.joinCode);
                    }
                });
            }
            
            const manageBtn = document.getElementById('teamManageBtn');
            if (manageBtn) {
                manageBtn.addEventListener('click', () => {
                    if (!currentTeamData?.joinCode) {
                        alert("Team code not available yet.");
                        return;
                    }
                    alert(`Share this code with teammates:\n\n${currentTeamData.joinCode}`);
                });
            }
            
            const assignBtn = document.getElementById('assignMissionBtn');
            if (assignBtn) {
                assignBtn.addEventListener('click', () => {
                    const library = document.getElementById('teamMissionLibrary');
                    if (library) {
                        library.scrollIntoView({ behavior: 'smooth' });
                    }
                });
            }
            
            const modalSubmit = document.getElementById('teamModalSubmit');
            const modalCancel = document.getElementById('teamModalCancel');
            const modalClose = document.getElementById('teamModalCloseBtn');
            const handleClose = () => closeTeamManagerModal();
            if (modalCancel) modalCancel.addEventListener('click', handleClose);
            if (modalClose) modalClose.addEventListener('click', handleClose);
            if (modalSubmit) {
                modalSubmit.addEventListener('click', async () => {
                    const input = document.getElementById('teamModalInput');
                    if (!input) return;
                    const value = input.value;
                    try {
                        if (teamModalMode === 'create') {
                            const teamId = await createTeamDocument(profile, value);
                            profile.teamId = teamId;
                            profile.teamRole = "leader";
                            await refreshTeamData(profile, true);
                        } else {
                            const teamId = await joinTeamByCode(profile, value);
                            profile.teamId = teamId;
                            profile.teamRole = "member";
                            await refreshTeamData(profile, true);
                        }
                        closeTeamManagerModal();
                    } catch (error) {
                        alert(error.message || "Unable to process the request.");
                    }
                });
            }
            
            const managerModal = document.getElementById('teamManagerModal');
            if (managerModal) {
                managerModal.addEventListener('click', (event) => {
                    if (event.target === managerModal) {
                        closeTeamManagerModal();
                    }
                });
            }
            
            const submissionCancel = document.getElementById('teamSubmissionCancel');
            const submissionClose = document.getElementById('teamSubmissionClose');
            const submissionSubmit = document.getElementById('teamSubmissionSubmit');
            const closeSubmission = () => closeTeamSubmissionModal();
            if (submissionCancel) submissionCancel.addEventListener('click', closeSubmission);
            if (submissionClose) submissionClose.addEventListener('click', closeSubmission);
            if (submissionSubmit) {
                submissionSubmit.addEventListener('click', async () => {
                    if (!teamSubmissionContext) {
                        closeTeamSubmissionModal();
                        return;
                    }
                    const noteInput = document.getElementById('teamSubmissionNote');
                    try {
                        await submitTeamMissionProgress(profile, teamSubmissionContext, noteInput.value);
                        closeTeamSubmissionModal();
                    } catch (error) {
                        alert(error.message || "Could not submit progress.");
                    }
                });
            }
            
            const submissionModal = document.getElementById('teamSubmissionModal');
            if (submissionModal) {
                submissionModal.addEventListener('click', (event) => {
                    if (event.target === submissionModal) {
                        closeTeamSubmissionModal();
                    }
                });
            }
            
            const missionContainer = document.getElementById('activeTeamMissions');
            if (missionContainer) {
                missionContainer.addEventListener('click', (event) => {
                    const target = event.target.closest('[data-team-action]');
                    if (!target) return;
                    const missionId = target.dataset.missionId;
                    const action = target.dataset.teamAction;
                    if (!missionId || !action) return;
                    if (action === 'submit') {
                        openTeamSubmissionModal(missionId);
                    } else if (action === 'review') {
                        approveTeamMission(profile, missionId).catch(error => alert(error.message || "Unable to approve mission."));
                    }
                });
            }
            
            const missionLibrary = document.getElementById('teamMissionLibrary');
            if (missionLibrary) {
                missionLibrary.addEventListener('click', (event) => {
                    const target = event.target.closest('[data-team-action="assign"]');
                    if (!target) return;
                    const templateId = target.dataset.templateId;
                    if (!templateId) return;
                    assignTeamMission(profile, templateId).catch(error => alert(error.message || "Unable to assign mission."));
                });
            }
        }

        function renderReminderStatus(preferences) {
            const status = document.getElementById('reminderStatus');
            if (!status) return;
            if (preferences.dailyReminderEnabled === false) {
                status.textContent = "Reminders are disabled.";
                return;
            }
            const hour = preferences.reminderHour ?? 9;
            const formatted = `${String(hour).padStart(2, '0')}:00`;
            status.textContent = `Daily reminder scheduled at ${formatted}.`;
        }

        function scheduleDailyReminder(hour = 9) {
            if (reminderTimeoutId) {
                clearTimeout(reminderTimeoutId);
                reminderTimeoutId = null;
            }
            const now = new Date();
            const nextTrigger = new Date();
            nextTrigger.setHours(hour, 0, 0, 0);
            if (nextTrigger <= now) {
                nextTrigger.setDate(nextTrigger.getDate() + 1);
            }
            const delay = nextTrigger - now;
            reminderTimeoutId = setTimeout(() => {
                showReminderNotification();
                scheduleDailyReminder(hour);
            }, delay);
        }

        function showReminderNotification() {
            const message = NOTIFICATION_TEMPLATES.reminder();
            pushNotification(message, "reminder");
            if ("Notification" in window && Notification.permission === "granted") {
                try {
                    new Notification("EcoQuest Reminder", {
                        body: message,
                        icon: "../images/logo.png"
                    });
                } catch (error) {
                    console.warn("Notification display failed:", error);
                }
            }
        }

        function initializeReminderSystem(profile) {
            const preferences = profile.notificationPreferences || { dailyReminderEnabled: true, reminderHour: 9 };
            const timeInput = document.getElementById('reminderTimeInput');
            if (timeInput && preferences.reminderHour != null) {
                timeInput.value = `${String(preferences.reminderHour).padStart(2, '0')}:00`;
            }
            renderReminderStatus(preferences);
            renderNotificationFeed();
            if (preferences.dailyReminderEnabled !== false) {
                scheduleDailyReminder(preferences.reminderHour || 9);
            }
            const permissionBtn = document.getElementById('requestPermissionBtn');
            if (permissionBtn) {
                permissionBtn.addEventListener('click', async () => {
                    if (!("Notification" in window)) {
                        alert("Browser notifications are not supported in this browser.");
                        return;
                    }
                    const permission = await Notification.requestPermission();
                    if (permission === "granted") {
                        pushNotification("Browser notifications enabled.", "success");
                    } else {
                        alert("We can only show in-app reminders without browser permission.");
                    }
                });
            }
            const saveReminderBtn = document.getElementById('saveReminderBtn');
            if (saveReminderBtn && timeInput) {
                saveReminderBtn.addEventListener('click', async () => {
                    const [hourPart] = timeInput.value.split(':');
                    const hour = Number(hourPart);
                    if (Number.isNaN(hour)) {
                        alert("Please enter a valid time.");
                        return;
                    }
                    try {
                        await updateUserProfile(currentUser.uid, {
                            notificationPreferences: {
                                ...(profile.notificationPreferences || {}),
                                dailyReminderEnabled: true,
                                reminderHour: hour
                            }
                        });
                        profile.notificationPreferences = {
                            ...(profile.notificationPreferences || {}),
                            dailyReminderEnabled: true,
                            reminderHour: hour
                        };
                        scheduleDailyReminder(hour);
                        renderReminderStatus(profile.notificationPreferences);
                        pushNotification("Reminder updated.", "success");
                    } catch (error) {
                        alert(error.message || "Unable to save reminder preference.");
                    }
                });
            }
            const testBtn = document.getElementById('testReminderBtn');
            if (testBtn) {
                testBtn.addEventListener('click', () => {
                    showReminderNotification();
                });
            }
        }

        async function renderTeamLeaderboard(profile) {
            const container = document.getElementById('teamLeaderboardContainer');
            if (!container) return;
            if (!profile.teamId) {
                container.innerHTML = `<p class="team-muted">Join a team to see the leaderboard.</p>`;
                return;
            }
            try {
                const { doc, getDoc } = await import("https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js");
                const { db } = await import("../js/firebase-config.js");
                const teamDoc = await getDoc(doc(db, "teams", profile.teamId));
                if (!teamDoc.exists()) {
                    container.innerHTML = `<p class="team-muted">Team not found.</p>`;
                    return;
                }
                const teamData = teamDoc.data();
                const members = teamData.members || {};
                const memberIds = Object.keys(members);
                if (memberIds.length === 0) {
                    container.innerHTML = `<p class="team-muted">No members yet.</p>`;
                    return;
                }
                const memberProfiles = [];
                for (const memberId of memberIds) {
                    try {
                        const memberResult = await getUserProfile(memberId);
                        if (memberResult.success) {
                            memberProfiles.push({
                                ...memberResult.data,
                                id: memberId,
                                role: members[memberId]?.role || 'member'
                            });
                        }
                    } catch (error) {
                        console.error(`Error loading member ${memberId}:`, error);
                    }
                }
                memberProfiles.sort((a, b) => (b.xp || 0) - (a.xp || 0));
                container.innerHTML = `
                    <div class="team-leaderboard-list">
                        ${memberProfiles.map((member, index) => `
                            <div class="team-leaderboard-item ${member.id === currentUser.uid ? 'current-user' : ''}">
                                <div class="leaderboard-rank">#${index + 1}</div>
                                <div class="leaderboard-info">
                                    <strong>${escapeHtml(member.displayName || member.email || 'Member')}</strong>
                                    <span class="leaderboard-role">${member.role === 'leader' ? 'üëë Leader' : member.role === 'co_leader' ? '‚≠ê Co-Leader' : 'Member'}</span>
                                </div>
                                <div class="leaderboard-stats">
                                    <span>${(member.xp || 0).toLocaleString()} XP</span>
                                    <span>${(member.ecoPoints || 0).toLocaleString()} Eco</span>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                `;
            } catch (error) {
                console.error("Error rendering team leaderboard:", error);
                container.innerHTML = `<p class="team-muted">Error loading leaderboard.</p>`;
            }
        }

        function renderWeeklyInsights(profile) {
            const container = document.getElementById('insightHighlights');
            if (!container) return;
            const dailyCompletions = profile.dailyQuestCompletions || {};
            const todayKey = getTodayDateString();
            const todayCount = Array.isArray(dailyCompletions[todayKey]) ? dailyCompletions[todayKey].length : 0;
            const now = new Date();
            const sevenDaysAgo = new Date(now.getTime() - (6 * 24 * 60 * 60 * 1000));
            let weeklyTotal = 0;
            Object.entries(dailyCompletions).forEach(([dateKey, quests]) => {
                const date = new Date(dateKey);
                if (date >= sevenDaysAgo && Array.isArray(quests)) {
                    weeklyTotal += quests.length;
                }
            });
            const teamMissions = profile.teamStats?.missionsCompleted || 0;
            container.innerHTML = `
                <div class="insight-chip">
                    <span>Today's quests</span>
                    <strong>${todayCount}/5</strong>
                </div>
                <div class="insight-chip">
                    <span>Quests last 7 days</span>
                    <strong>${weeklyTotal}</strong>
                </div>
                <div class="insight-chip">
                    <span>Team missions cleared</span>
                    <strong>${teamMissions}</strong>
                </div>
            `;
            renderInsightCharts(profile);
        }

        async function renderInsightCharts(profile) {
            const dailyCompletions = profile.dailyQuestCompletions || {};
            const now = new Date();
            const labels = [];
            const questData = [];
            for (let i = 6; i >= 0; i--) {
                const date = new Date(now);
                date.setDate(date.getDate() - i);
                const dateKey = date.toISOString().split('T')[0];
                labels.push(date.toLocaleDateString('en-US', { weekday: 'short' }));
                const quests = Array.isArray(dailyCompletions[dateKey]) ? dailyCompletions[dateKey].length : 0;
                questData.push(quests);
            }
            
            const questTrendCtx = document.getElementById('questTrendChart');
            if (questTrendCtx && window.Chart) {
                new Chart(questTrendCtx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Quests Completed',
                            data: questData,
                            borderColor: '#4caf50',
                            backgroundColor: 'rgba(76, 175, 80, 0.1)',
                            tension: 0.4,
                            fill: true
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false }
                        },
                        scales: {
                            y: { beginAtZero: true, ticks: { stepSize: 1 } }
                        }
                    }
                });
            }

            const completedQuests = profile.completedQuests || [];
            const categoryCounts = {};
            if (window.currentQuests) {
                window.currentQuests.forEach(quest => {
                    if (completedQuests.includes(quest.id)) {
                        const cat = quest.categoryName || 'Other';
                        categoryCounts[cat] = (categoryCounts[cat] || 0) + 1;
                    }
                });
            }
            const categoryCtx = document.getElementById('categoryDistributionChart');
            if (categoryCtx && window.Chart && Object.keys(categoryCounts).length > 0) {
                new Chart(categoryCtx, {
                    type: 'doughnut',
                    data: {
                        labels: Object.keys(categoryCounts),
                        datasets: [{
                            data: Object.values(categoryCounts),
                            backgroundColor: [
                                '#4caf50', '#2196F3', '#FFC107', '#9C27B0', '#00BCD4', '#8BC34A', '#66BB6A'
                            ]
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { position: 'bottom' }
                        }
                    }
                });
            }

            const xpGrowthCtx = document.getElementById('xpGrowthChart');
            if (xpGrowthCtx && window.Chart) {
                const currentXP = profile.xp || 0;
                const currentEco = profile.ecoPoints || 0;
                new Chart(xpGrowthCtx, {
                    type: 'bar',
                    data: {
                        labels: ['XP', 'EcoPoints'],
                        datasets: [{
                            label: 'Total',
                            data: [currentXP, currentEco],
                            backgroundColor: ['#4caf50', '#2196F3']
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false }
                        },
                        scales: {
                            y: { beginAtZero: true }
                        }
                    }
                });
            }
        }
        
        let lastQuestCompletionTime = 0;
        const MIN_QUEST_COMPLETION_INTERVAL = 1000;
        // Arvutab v√§rske koha pingereas ja salvestab parema rekordi.
        async function calculateAndUpdateBestRank(userId) {
            try {
                const result = await getAllUsers();
                if (!result.success) {
                    return;
                }

                const users = result.data || [];
                users.sort((a, b) => (b.xp || 0) - (a.xp || 0));

                const userIndex = users.findIndex(u => u.id === userId);
                const currentRank = userIndex >= 0 ? userIndex + 1 : null;

                if (!currentRank || currentRank <= 0) {
                    return;
                }

                // V√µtab profiilist seni parima koha
                const profileResult = await getUserProfile(userId);
                if (!profileResult.success) {
                    return;
                }

                const profile = profileResult.data;
                const bestRank = profile.bestRank;

                if (bestRank === null || bestRank === undefined) {
                    await updateUserProfile(userId, { bestRank: currentRank });
                } else if (currentRank < bestRank) {
                    await updateUserProfile(userId, { bestRank: currentRank });
                }
            } catch (error) {
                console.error("Error calculating/updating best rank:", error);
            }
        }
        
        function showSuccessAnimation(message, duration = 3000) {
            const successDiv = document.createElement('div');
            successDiv.className = 'success-animation';
            successDiv.innerHTML = `
                <div class="success-animation-icon">‚úÖ</div>
                <h3>Success!</h3>
                <p>${message}</p>
            `;
            document.body.appendChild(successDiv);
            
            setTimeout(() => {
                successDiv.style.animation = 'successFadeIn 0.3s ease-out reverse';
                setTimeout(() => {
                    if (document.body.contains(successDiv)) {
                        document.body.removeChild(successDiv);
                    }
                }, 300);
            }, duration);
        }
        
        
        // Avab foto modali ja k√§ivitab j√§rjestikuse kinnitamise voo.
        function showPhotoUploadModal(questIds, completionData) {
            currentQuestIndex = 0;
            verifiedPhotos = {};
            pendingQuestCompletion = { 
                questIds, 
                completionData,
                reflections: { ...questReflectionNotes }
            };
            showQuestPhotoUpload(0);
        }
        
        // Kuvab √ºhe missiooni fotojuhise ja hoiab modali oleku korras.
        function showQuestPhotoUpload(index) {
            if (!pendingQuestCompletion || !pendingQuestCompletion.questIds) {
                console.error('pendingQuestCompletion is null or invalid');
                return;
            }
            
            if (index >= pendingQuestCompletion.questIds.length) {
                completeAllQuestsWithPhotos();
                return;
            }
            
            const modal = document.getElementById('photoUploadModal');
            const photoInput = document.getElementById('photoInput');
            const photoPreview = document.getElementById('photoPreview');
            const photoPreviewImg = document.getElementById('photoPreviewImg');
            const photoUploadBtn = document.getElementById('photoUploadBtn');
            const photoRemoveBtn = document.getElementById('photoRemoveBtn');
            const photoCancelBtn = document.getElementById('photoCancelBtn');
            const photoModalClose = document.getElementById('photoModalClose');
            const photoInstruction = document.querySelector('.photo-instruction');
            const photoLoadingIndicator = document.getElementById('photoLoadingIndicator');
            
            if (!modal || !photoInput || !photoInstruction) {
                console.error('Required modal elements not found', {
                    modal: !!modal,
                    photoInput: !!photoInput,
                    photoInstruction: !!photoInstruction
                });
                return;
            }
            
            currentQuestIndex = index;
            const questId = pendingQuestCompletion.questIds[index];
            
            // J√§ta vahele kui see missioon on juba kinnitatud
            if (verifiedPhotos[questId]) {
                showQuestPhotoUpload(index + 1);
                return;
            }
            
            const quest = pendingQuestCompletion.completionData.quests.find(q => q.id === questId);
            const questTitle = quest ? quest.title : `Quest ${index + 1}`;
            
            if (photoInput) {
                photoInput.value = '';
            }
            if (photoPreview) {
                photoPreview.style.display = 'none';
            }
            if (photoUploadBtn) {
                photoUploadBtn.disabled = true;
            }
            photoInstruction.textContent = `üì∏ Take a photo as proof for: "${questTitle}"\n(${index + 1} of ${pendingQuestCompletion.questIds.length})\n\nNote: Photo will not be stored, only used for verification.`;
            
            if (modal) {
                modal.style.display = 'flex';
            }
            
            let selectedFile = null;
            
            photoInput.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
            // Check file type
                if (!file.type.startsWith('image/')) {
                    alert('Please select an image file.');
                    photoInput.value = '';
                    return;
                }
                
            // Check file size (max 10MB)
                if (file.size > 10 * 1024 * 1024) {
                    alert('Image is too large. Please select an image smaller than 10MB.');
                    photoInput.value = '';
                    return;
                }
                
                try {
                    if (photoLoadingIndicator) {
                        photoLoadingIndicator.style.display = 'flex';
                    }
                    if (photoPreview) {
                        photoPreview.style.display = 'none';
                    }
                    if (photoUploadBtn) {
                        photoUploadBtn.disabled = true;
                    }
                    
                    // Kinnitab ainult foto olemasolu, tihendust pole vaja
                    selectedFile = file;
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        if (photoLoadingIndicator) {
                            photoLoadingIndicator.style.display = 'none';
                        }
                        if (photoPreviewImg) {
                            photoPreviewImg.src = event.target.result;
                        }
                        if (photoPreview) {
                            photoPreview.style.display = 'block';
                        }
                        if (photoUploadBtn) {
                            photoUploadBtn.disabled = false;
                        }
                    };
                    reader.onerror = () => {
                        if (photoLoadingIndicator) {
                            photoLoadingIndicator.style.display = 'none';
                        }
                        alert('Failed to load image. Please try another photo.');
                        photoInput.value = '';
                        selectedFile = null;
                    };
                    reader.readAsDataURL(file);
                } catch (error) {
                    if (photoLoadingIndicator) {
                        photoLoadingIndicator.style.display = 'none';
                    }
                    alert('Failed to load image: ' + (error.message || 'Unknown error'));
                    photoInput.value = '';
                    selectedFile = null;
                }
            };
            
            photoRemoveBtn.onclick = () => {
                if (photoInput) {
                    photoInput.value = '';
                }
                if (photoPreview) {
                    photoPreview.style.display = 'none';
                }
                if (photoUploadBtn) {
                    photoUploadBtn.disabled = true;
                }
                selectedFile = null;
            };
            
            photoUploadBtn.onclick = async () => {
                if (!selectedFile) {
                    alert('Please take a photo first.');
                    return;
                }
                // M√§rgib foto kinnitatuks (pilti ei salvestata)
                verifiedPhotos[questId] = true;
                
                // Sulgeb modali korraks enne j√§rgmise missiooni kuvamist
                if (modal) {
                    modal.style.display = 'none';
                }
                
                // Liigub j√§rgmise missiooni juurde
                setTimeout(() => {
                    showQuestPhotoUpload(index + 1);
                }, 100);
            };
            
            const closeModal = () => {
                const completionData = pendingQuestCompletion?.completionData;
                if (modal) {
                    modal.style.display = 'none';
                }
                pendingQuestCompletion = null;
                currentQuestIndex = 0;
                verifiedPhotos = {};
                if (completionData?.completeButton) {
                    completionData.completeButton.disabled = false;
                    completionData.completeButton.textContent = "Complete Selected Missions";
                }
            };
            
            photoCancelBtn.onclick = closeModal;
            photoModalClose.onclick = closeModal;
            modal.onclick = (e) => { if (e.target === modal) closeModal(); };
        }
        
        
        // kontrollib, et k√µik vajalikud fotod on olemas ja alustab missioonide l√µpetamise protsessi
        async function completeAllQuestsWithPhotos() {
            const modal = document.getElementById('photoUploadModal');
            const completionData = pendingQuestCompletion?.completionData;
            const questIds = pendingQuestCompletion?.questIds || [];
            const reflections = pendingQuestCompletion?.reflections || {};
            
            if (modal) {
                modal.style.display = 'none';
            }
            
            // kontrollib, et k√µik vajalikud andmed on olemas
            if (!completionData || questIds.length === 0) {
                console.error('Missing completion data or quest IDs');
                alert('Error: Missing quest completion data. Please try again.');
                // taastab nupu oleku, et kasutaja saaks uuesti proovida
                if (completionData?.completeButton) {
                    completionData.completeButton.disabled = false;
                    completionData.completeButton.textContent = "Complete Selected Missions";
                }
                // puhastab oleku
                pendingQuestCompletion = null;
                verifiedPhotos = {};
                return;
            }
            
            try {
                await completeQuestsWithPhoto(questIds, completionData, verifiedPhotos, reflections);
                questIds.forEach(questId => {
                    delete questReflectionNotes[questId];
                });
            } catch (error) {
                console.error('Error in completeAllQuestsWithPhotos:', error);
                const errorMessage = getErrorMessage(error);
                alert(`Unable to complete quests:\n\n${errorMessage}`);
            } finally {
                pendingQuestCompletion = null;
                verifiedPhotos = {};
            }
        }
        
        // lisab XP, uuendab profiili ja v√§ltib topeltmissioonide l√µpetamist
        async function completeQuestsWithPhoto(questIds, completionData, questPhotoMap, questReflections = {}) {
            const { currentUser, profile, quests, checkboxes } = completionData;
            
            try {
                // kontrollib, et profiil on olemas
                if (!profile || !currentUser) {
                    throw new Error("Missing user or profile data");
                }
                
                const currentQuestCompletionCount = profile.questCompletionCount || {};
                const allQuestsCompleted = profile.allQuestsCompleted || false;
            
                let totalXpEarned = 0;
                const xpRewardsByQuest = {};
                const validQuestIds = [];
                
                // kontrollib iga missiooni kehtivust ja fotode olemasolu
                for (const questId of questIds) {
                    const quest = quests.find(q => q.id === questId);
                    if (!quest) {
                        continue;
                    }
                    
                    const needsPhoto = await questRequiresPhoto(questId);
                    
                    // kontrollib, et fotoga missioonidel on foto olemas
                    if (needsPhoto && !questPhotoMap[questId]) {
                        continue;
                    }
                    
                    // kontrollib, et XP on positiivne arv
                    const baseXpReward = Number(quest.xp) || 0;
                    if (baseXpReward < 0) continue;
                    
                    const timesCompleted = Number(currentQuestCompletionCount[questId]) || 0;
                    const bonusMultiplier = getQuestBonusMultiplier(timesCompleted);
                    const finalXpReward = Math.floor(baseXpReward * bonusMultiplier);
                    
                    // kontrollib, et arvutused on kehtivad
                    if (isNaN(finalXpReward) || finalXpReward < 0) continue;
                    
                    totalXpEarned += finalXpReward;
                    xpRewardsByQuest[questId] = finalXpReward;
                    validQuestIds.push(questId);
                    currentQuestCompletionCount[questId] = timesCompleted + 1;
                }
                
                // kontrollib, et v√§hemalt √ºks missioon on kehtiv
                if (validQuestIds.length === 0) {
                    console.error("No valid quests to complete", {
                        questIds: questIds,
                        questPhotoMap: questPhotoMap,
                        verifiedQuests: Object.keys(questPhotoMap),
                        questsAvailable: quests.map(q => q.id)
                    });
                    throw new Error("No valid quests to complete. Please make sure you took photos for all selected quests.");
                }
                
                const uniqueCompletedQuestIds = [...new Set(validQuestIds)];
                
                // arvutab XP, taseme ja √∂koloogilised punktid
                const userCurrentXp = profile.xp || 0;
                const userCurrentEcoPoints = profile.ecoPoints || 0;
                const userCurrentMissions = profile.missionsCompleted || 0;
                const userCurrentLevel = profile.level || calculateLevel(userCurrentXp);
                const userCompletedQuests = profile.completedQuests || [];
                const userDailyCompletedQuests = profile.dailyQuestsCompleted || [];
                const userBadgesCount = (profile.badges || []).length;
                
                const userNewXp = userCurrentXp + totalXpEarned;
                const userNewLevel = calculateLevel(userNewXp);
                
                const ecoPointsAtNewLevel = calculateEcoPoints(userNewXp, userNewLevel, userBadgesCount);
                const ecoPointsAtCurrentLevel = calculateEcoPoints(userCurrentXp, userCurrentLevel, userBadgesCount);
                
                let baseEcoPointsEarned = ecoPointsAtNewLevel - ecoPointsAtCurrentLevel;
                
                let replayBonusEcoPoints = 0;
                if (allQuestsCompleted) {
                    uniqueCompletedQuestIds.forEach(questId => {
                        const timesCompleted = currentQuestCompletionCount[questId] || 0;
                        if (timesCompleted > 0) {
                            const replayBonusMultiplier = Math.min(timesCompleted * 0.1, 0.5);
                            const quest = quests.find(q => q.id === questId);
                            const questBaseEcoPoints = (quest?.xp || 0) * 0.1;
                            replayBonusEcoPoints += Math.floor(questBaseEcoPoints * replayBonusMultiplier);
                        }
                    });
                }
                
                const userNewEcoPoints = userCurrentEcoPoints + baseEcoPointsEarned + replayBonusEcoPoints;
                const userNewMissions = userCurrentMissions + uniqueCompletedQuestIds.length;
                const updatedCompletedQuests = Array.isArray(userCompletedQuests) 
                    ? [...new Set([...userCompletedQuests, ...uniqueCompletedQuestIds])]
                    : uniqueCompletedQuestIds;
                const updatedDailyCompleted = Array.isArray(userDailyCompletedQuests)
                    ? [...new Set([...userDailyCompletedQuests, ...uniqueCompletedQuestIds])]
                    : uniqueCompletedQuestIds;
                
                const completionStatus = await checkAllQuestsCompleted(updatedCompletedQuests);
                const isFirstTimeCompletingAll = completionStatus.allCompleted && !allQuestsCompleted;
                
                const currentAllQuestsCompletedCount = profile.allQuestsCompletedCount || 0;
                let newAllQuestsCompletedCount = currentAllQuestsCompletedCount;
                
                const completedAllDailyQuests = updatedDailyCompleted.length >= quests.length && quests.length > 0;
                const hadCompletedAllDailyQuests = userDailyCompletedQuests.length >= quests.length && quests.length > 0;
                
                if (allQuestsCompleted && completedAllDailyQuests && !hadCompletedAllDailyQuests) {
                    newAllQuestsCompletedCount = currentAllQuestsCompletedCount + 1;
                }
                
                if (isFirstTimeCompletingAll) {
                    newAllQuestsCompletedCount = 1;
                    // esimene kord kui k√µik questi on tehtud - n√§itab erilist animatsiooni
                    setTimeout(() => {
                        showReplayModeUnlockAnimation();
                    }, 500);
                }
                
                const today = getTodayDateString();
                let dailyCompletions = profile.dailyQuestCompletions || {};
                if (typeof dailyCompletions !== 'object') {
                    dailyCompletions = {};
                }
                const todayCompletions = Array.isArray(dailyCompletions[today]) 
                    ? [...new Set(dailyCompletions[today])] 
                    : [];
                dailyCompletions[today] = [...new Set([...todayCompletions, ...uniqueCompletedQuestIds])];
                
                const updateResult = await updateUserProfile(currentUser.uid, {
                    xp: userNewXp,
                    ecoPoints: userNewEcoPoints,
                    missionsCompleted: userNewMissions,
                    level: userNewLevel,
                    completedQuests: updatedCompletedQuests,
                    dailyQuestsCompleted: updatedDailyCompleted,
                    questCompletionCount: currentQuestCompletionCount,
                    allQuestsCompleted: isFirstTimeCompletingAll || allQuestsCompleted,
                    allQuestsCompletedCount: newAllQuestsCompletedCount,
                    lastQuestCompletionTime: new Date().toISOString(),
                    dailyQuestCompletions: dailyCompletions
                });
                
                if (updateResult.success) {
                    const xpProgress = getXPProgress(userNewXp, userNewLevel);
                    const totalEcoPointsEarned = userNewEcoPoints - userCurrentEcoPoints;
                    const didLevelUp = userNewLevel > userCurrentLevel;
                    
                    await updateUI(userNewXp, userNewLevel, userNewMissions, userNewEcoPoints, currentUser, userCurrentLevel, updatedCompletedQuests);
                    await updateQuestCharts(updatedCompletedQuests);
                    
                    await calculateAndUpdateBestRank(currentUser.uid);
                    
                    const hasReplayBonus = allQuestsCompleted && uniqueCompletedQuestIds.some(id => {
                        const count = currentQuestCompletionCount[id] || 0;
                        return count > 0;
                    });
                    const bonusText = hasReplayBonus ? " (with bonus)" : "";
                    
                    let successMessage = `Completed ${uniqueCompletedQuestIds.length} mission(s)!`;
                    successMessage += `\n‚ú® +${totalXpEarned} XP${bonusText}`;
                    successMessage += `\nüí∞ +${totalEcoPointsEarned} EcoPoints`;
                    
                    if (didLevelUp) {
                        successMessage += `\nüéâ ${getBadgeNameForLevel(userNewLevel)} Badge Unlocked!`;
                    }
                    
                    showSuccessAnimation(successMessage, 4000);
                    
                    await logQuestAudits(uniqueCompletedQuestIds.map(questId => ({
                        userId: currentUser.uid,
                        questId: questId,
                        questTitle: getQuestTitleById(questId),
                        reflection: questReflections[questId] || null,
                        xpEarned: xpRewardsByQuest[questId] || 0,
                        ecoEarned: uniqueCompletedQuestIds.length > 0 
                            ? Math.max(0, Math.round(totalEcoPointsEarned / uniqueCompletedQuestIds.length))
                            : 0,
                        type: "solo"
                    })));
                    
                    setTimeout(() => {
                        let alertMessage = `Great job! You completed ${uniqueCompletedQuestIds.length} mission(s)!\n\n`;
                        alertMessage += `‚ú® Earned: ${totalXpEarned} XP${bonusText}\n`;
                        alertMessage += `üí∞ Earned: ${totalEcoPointsEarned} EcoPoints\n`;
                        alertMessage += `üì∏ Photo proof verified!\n\n`;
                        alertMessage += `Level ${userNewLevel} - ${xpProgress.current} / ${xpProgress.required} XP to next level`;
                        
                        if (didLevelUp) {
                            alertMessage += `\n\nüéâ New Badge Unlocked: ${getBadgeNameForLevel(userNewLevel)} Badge!`;
                        }
                        
                        if (!completionStatus.allCompleted && completionStatus.totalQuests > 0) {
                            alertMessage += `\n\nüìä Quest Progress: ${completionStatus.completedCount} / ${completionStatus.totalQuests} quests completed`;
                        } else if (allQuestsCompleted) {
                            alertMessage += `\n\nüîÑ Replay Mode: Repeat quests to earn even more rewards!`;
                        }
                        
                        alert(alertMessage);
                    }, 1000);
                    
                    await renderQuests(quests, currentUser, updatedCompletedQuests, updatedDailyCompleted);
                    
                    if (completionData.completeButton) {
                        completionData.completeButton.disabled = false;
                        completionData.completeButton.textContent = "Complete Selected Missions";
                    }
                    lastQuestCompletionTime = Date.now();
                } else {
                    const errorMsg = getErrorMessage(updateResult.error);
                    throw new Error(`Failed to update profile: ${errorMsg}`);
                }
            } catch (error) {
                console.error("Error completing quests with photo:", error);
                const errorMessage = getErrorMessage(error);
                alert(`Unable to complete quests:\n\n${errorMessage}\n\nPlease try again or contact support if the problem persists.`);
                if (completionData.completeButton) {
                    completionData.completeButton.disabled = false;
                    completionData.completeButton.textContent = "Complete Selected Missions";
                }
            }
        }

        // tuvastab ebanormaalseid mustreid missioonide l√µpetamisel
        async function detectAbnormalPattern(profile, questIds) {
            try {
                // kontrollib, et profiil on kehtiv objekt
                if (!profile || typeof profile !== 'object') {
                    return [];
                }
                
                // kontrollib, et questIds on massiiv
                if (!questIds || !Array.isArray(questIds) || questIds.length === 0) {
                    return [];
                }
                
                const warnings = [];
                
                // kontrollib ainult p√§evast limiiti (5 missiooni p√§evas)
                const today = getTodayDateString();
                const dailyCompletions = profile.dailyQuestCompletions || {};
                // eemaldab duplikaadid, et v√§ltida topeltarvutamist
                const todayCompletions = Array.isArray(dailyCompletions[today]) 
                    ? [...new Set(dailyCompletions[today])]
                    : [];
                const uniqueQuestIds = [...new Set(questIds)];
                
                // eemaldab questi, mis on juba t√§na tehtud (et v√§ltida topeltarvutamist)
                const newQuestIds = uniqueQuestIds.filter(id => !todayCompletions.includes(id));
                const newTotal = todayCompletions.length + newQuestIds.length;
                
                // maksimaalne limiit p√§evas
                const MAX_DAILY_QUESTS = 5;
                if (newTotal > MAX_DAILY_QUESTS) {
                    warnings.push({
                        type: "daily_limit",
                        message: `You can only complete ${MAX_DAILY_QUESTS} quests per day. You have already completed ${todayCompletions.length} quests today.`
                    });
                }
                
                return warnings;
            } catch (error) {
                // logib vea, aga ei katkesta rakendust
                console.error("Error in detectAbnormalPattern:", error);
                return [];
            }
        }


        function getRandomQuests(quests, completedQuestIds, allQuestsCompleted = false, count = 5) {
            if (allQuestsCompleted) {
                const shuffled = [...quests].sort(() => 0.5 - Math.random());
                return shuffled.slice(0, Math.min(count, shuffled.length));
            }
            
            const availableQuests = quests.filter(q => !completedQuestIds.includes(q.id));
            if (availableQuests.length === 0) {
                return quests.slice(0, Math.min(count, quests.length));
            }
            const shuffled = [...availableQuests].sort(() => 0.5 - Math.random());
            return shuffled.slice(0, Math.min(count, shuffled.length));
        }

        async function resetDailyQuests(user, allQuests, completedQuests, allQuestsCompleted = false) {
            try {
                const newResetTime = getCurrentTimestamp();
                const newQuests = getRandomQuests(allQuests, completedQuests, allQuestsCompleted, 5);
                
                await updateUserProfile(user.uid, {
                    lastQuestResetTime: newResetTime,
                    currentDailyQuests: newQuests.map(q => q.id),
                    dailyQuestsCompleted: []
                });
                
                return newQuests;
            } catch (error) {
                console.error("Error resetting daily quests:", error);
                throw error;
            }
        }

        async function loadUserDailyQuests(user, allQuests, completedQuests) {
            try {
                const profileResult = await getUserProfile(user.uid);
                if (!profileResult.success) {
                    throw new Error("Failed to load profile");
                }
                
                const profile = profileResult.data;
                const lastResetTime = profile.lastQuestResetTime;
                const currentDailyQuestIds = profile.currentDailyQuests || [];
                const dailyQuestsCompleted = profile.dailyQuestsCompleted || [];
                const allQuestsCompleted = profile.allQuestsCompleted || false;
                
                if (shouldResetQuests(lastResetTime)) {
                    const newQuests = await resetDailyQuests(user, allQuests, completedQuests, allQuestsCompleted);
                    startCountdown(getCurrentTimestamp(), () => {
                        location.reload();
                    });
                    return { quests: newQuests, resetTime: getCurrentTimestamp() };
                } else {
                    // filtreerib allQuests, et leida p√§evased questi
                    // kui quest on currentDailyQuestIds'is, siis on see saadaval (isegi kui on varem tehtud)
                    const currentQuests = allQuests.filter(q => currentDailyQuestIds.includes(q.id));
                    
                    // kui leitud questi on v√§hem kui oodatud, proovib t√§iendada
                    if (currentQuests.length < currentDailyQuestIds.length) {
                        // laeb quests.json, et saada √µiged quest andmed
                        const questsData = await loadQuestsData();
                        const missingQuestIds = currentDailyQuestIds.filter(id => !currentQuests.some(q => q.id === id));
                        
                        for (const questId of missingQuestIds) {
                            const questMapping = QUEST_ID_MAPPING[questId];
                            if (questMapping && questsData) {
                                // otsib quest'i quests.json'ist
                                let questTitle = `Quest ${questId}`;
                                let questXP = 35;
                                
                                for (const jsonId of questMapping.jsonIds || []) {
                                    for (const category of questsData.categories || []) {
                                        const quest = category.quests?.find(q => q.id === jsonId);
                                        if (quest) {
                                            questTitle = quest.shortName || quest.description || questTitle;
                                            questXP = quest.xp || questXP;
                                            break;
                                        }
                                    }
                                    if (questTitle !== `Quest ${questId}`) break;
                                }
                                
                                // loob quest objekti √µigete andmetega
                                currentQuests.push({
                                    id: questId,
                                    title: questTitle,
                                    reward: `${questXP} XP`,
                                    xp: questXP,
                                    category: questMapping.category || "unknown",
                                    categoryName: questMapping.categoryName || "Unknown",
                                    categoryIcon: questMapping.categoryIcon || "üìã",
                                    categoryColor: questMapping.categoryColor || "#999999"
                                });
                            } else if (questMapping) {
                                // kui quests.json ei ole saadaval, kasutab minimaalset objekti
                                currentQuests.push({
                                    id: questId,
                                    title: `Quest ${questId}`,
                                    reward: "XP",
                                    xp: 35,
                                    category: questMapping.category || "unknown",
                                    categoryName: questMapping.categoryName || "Unknown",
                                    categoryIcon: questMapping.categoryIcon || "üìã",
                                    categoryColor: questMapping.categoryColor || "#999999"
                                });
                            }
                        }
                    }
                    
                    // Eƒüer currentDailyQuestIds'de 5'ten az quest varsa veya hi√ß quest yoksa, reset yap
                    if (currentQuests.length === 0 || currentDailyQuestIds.length < 5) {
                        const newQuests = await resetDailyQuests(user, allQuests, completedQuests, allQuestsCompleted);
                        startCountdown(getCurrentTimestamp(), () => {
                            location.reload();
                        });
                        return { quests: newQuests, resetTime: getCurrentTimestamp() };
                    }
                    startCountdown(lastResetTime, () => {
                        location.reload();
                    });
                    return { quests: currentQuests, resetTime: lastResetTime, dailyCompleted: dailyQuestsCompleted };
                }
            } catch (error) {
                console.error("Error loading daily quests:", error);
                throw error;
            }
        }

        async function renderQuests(quests, currentUser, completedQuestIds, dailyCompletedQuests = []) {
            const missionList = document.getElementById("missionList");
            missionList.innerHTML = "";

            if (quests.length === 0) {
                missionList.innerHTML = "<p style='color: #999; text-align: center; padding: 20px;'>No missions available today. Check back tomorrow!</p>";
                return;
            }

            const profileResult = await getUserProfile(currentUser.uid);
            const profile = profileResult.success ? profileResult.data : {};
            const questCompletionCount = profile.questCompletionCount || {}; // { questId: loendur }
            const allQuestsCompleted = profile.allQuestsCompleted || false;
            const currentDailyQuestIds = profile.currentDailyQuests || []; // p√§evased questi ID-d

            const questsData = await loadQuestsData();
            const categoryStats = questsData ? calculateQuestProgress(questsData, completedQuestIds || []) : null;

            quests.forEach((quest, index) => {
                const isCompletedToday = dailyCompletedQuests.includes(quest.id);
                const wasEverCompleted = completedQuestIds.includes(quest.id);
                // kui quest on p√§evastes questides (currentDailyQuests), siis saab seda t√§ita isegi kui on varem tehtud
                // replay mode'is v√µi kui quest on p√§evastes questides, ei keela checkbox'i
                const isInDailyQuests = currentDailyQuestIds.includes(quest.id);
                // kui quest on p√§evastes questides, siis ei keela seda (lubab uuesti t√§ita)
                // Replay mode'da: ega quest on t√§na juba tehtud, siis keela uuesti t√§itmine
                const isCompleted = allQuestsCompleted 
                    ? isCompletedToday  // Replay mode'da: kui t√§na juba tehtud, siis disabled
                    : (isCompletedToday || (wasEverCompleted && !isInDailyQuests));
                
                const completionCount = questCompletionCount[quest.id] || 0;
                const bonusMultiplier = getQuestBonusMultiplier(completionCount);
                const bonusXP = Math.floor(quest.xp * bonusMultiplier);
                const missionItem = document.createElement("div");
                // n√§itab visuaalselt, et quest on varem tehtud, aga ei keela uuesti t√§itmist kui on p√§evastes questides
                // kui quest on p√§evastes questides, siis ei n√§ita seda t√§idetuna (lubab uuesti t√§ita)
                const visualCompleted = allQuestsCompleted ? isCompletedToday : (isCompletedToday || (wasEverCompleted && !isInDailyQuests));
                missionItem.className = `mission-item ${visualCompleted ? 'completed' : ''}`;
                missionItem.dataset.questIndex = index;
                missionItem.dataset.questId = quest.id;
                missionItem.dataset.category = quest.category;
                
                const checkbox = document.createElement("input");
                checkbox.type = "checkbox";
                checkbox.id = `mission-${index + 1}`;
                // kui quest on p√§evastes questides, ei keela checkbox'i (lubab uuesti t√§ita)
                // replay mode'is v√µi kui quest on p√§evastes questides, ei keela checkbox'i
                checkbox.disabled = isCompleted;
                checkbox.checked = visualCompleted;
                
                const questContent = document.createElement("div");
                questContent.className = "quest-content";
                
                const categoryInfo = categoryStats?.find(cat => cat.id === quest.category);
                const categoryBadge = document.createElement("div");
                categoryBadge.className = "quest-category-badge";
                categoryBadge.style.borderLeft = `4px solid ${quest.categoryColor || "#999"}`;
                
                const categoryHeader = document.createElement("div");
                categoryHeader.className = "category-header";
                categoryHeader.innerHTML = `
                    <span class="category-icon-badge" style="background: ${quest.categoryColor || "#999"}20; color: ${quest.categoryColor || "#999"}">
                        ${quest.categoryIcon || "üìã"} ${quest.categoryName || "Unknown"}
                    </span>
                    ${categoryInfo ? `
                        <span class="category-progress-badge">
                            ${categoryInfo.completedQuests}/${categoryInfo.totalQuests} quests
                        </span>
                    ` : ''}
                `;
                
                let categoryProgressHTML = '';
                if (categoryInfo) {
                    const progressPercent = categoryInfo.completionPercentage;
                    categoryProgressHTML = `
                        <div class="category-mini-progress">
                            <div class="category-mini-progress-bar" style="background: ${quest.categoryColor || "#999"}20;">
                                <div class="category-mini-progress-fill" style="width: ${progressPercent}%; background: ${quest.categoryColor || "#999"};"></div>
                            </div>
                            <span class="category-mini-progress-text">${progressPercent.toFixed(0)}% complete</span>
                        </div>
                    `;
                }
                
                categoryBadge.innerHTML = categoryHeader.outerHTML + categoryProgressHTML;
                
                const questDetails = document.createElement("div");
                questDetails.className = "quest-details";
                
                const label = document.createElement("label");
                label.htmlFor = `mission-${index + 1}`;
                label.className = "quest-title";
                label.textContent = quest.title;
                if (isCompleted) {
                    label.style.textDecoration = "line-through";
                    label.style.opacity = "0.6";
                }
                
                const questStats = document.createElement("div");
                questStats.className = "quest-stats";
                
                let carbonReduction = 0;
                if (questsData) {
                    const category = questsData.categories.find(cat => cat.id === quest.category);
                    if (category) {
                        const questInJson = category.quests.find(q => {
                            const mapping = QUEST_ID_MAPPING[quest.id];
                            return mapping && mapping.jsonIds.includes(q.id);
                        });
                        if (questInJson) {
                            carbonReduction = questInJson.carbonFootprintReduction;
                        }
                    }
                }
                
                const badgeInfo = categoryInfo && categoryInfo.completedQuests === categoryInfo.totalQuests && categoryInfo.totalQuests > 0
                    ? `<span class="badge-unlocked-indicator">üèÜ ${categoryInfo.badgeName} Unlocked!</span>`
                    : categoryInfo && categoryInfo.totalQuests > 0
                    ? `<span class="badge-next-indicator">Next: ${categoryInfo.badgeName} (${categoryInfo.totalQuests - categoryInfo.completedQuests} quests left)</span>`
                    : '';
                
                let bonusInfo = '';
                if (completionCount > 0 && allQuestsCompleted) {
                    const bonusPercent = Math.round((bonusMultiplier - 1) * 100);
                    bonusInfo = `<div class="quest-bonus-info" style="
                        background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
                        color: #333;
                        padding: 4px 8px;
                        border-radius: 6px;
                        font-size: 11px;
                        font-weight: 600;
                        margin-top: 4px;
                        display: inline-block;
                    ">üîÑ Repeat ${completionCount + 1}: +${bonusPercent}% Bonus XP!</div>`;
                }
                
                questStats.innerHTML = `
                    <div class="quest-rewards">
                        <span class="reward-xp">+${bonusXP} XP${completionCount > 0 && allQuestsCompleted ? ` <span style="color: #ffd700; font-weight: 600;">(+${bonusXP - quest.xp})</span>` : ''}</span>
                        ${carbonReduction > 0 ? `<span class="reward-carbon">-${carbonReduction.toFixed(1)} kg CO‚ÇÇ</span>` : ''}
                    </div>
                    ${bonusInfo}
                    ${badgeInfo ? `<div class="quest-badge-info">${badgeInfo}</div>` : ''}
                `;
                
                questDetails.appendChild(label);
                questDetails.appendChild(questStats);
                
                questContent.appendChild(categoryBadge);
                questContent.appendChild(questDetails);
                
                missionItem.appendChild(checkbox);
                missionItem.appendChild(questContent);
                missionList.appendChild(missionItem);
                
                // Quest start tracking is disabled - no additional verification needed
            });

            const completeButton = document.createElement("button");
            completeButton.className = "complete-button";
            completeButton.id = "completeMissionsButton";
            completeButton.textContent = "Complete Selected Missions";
            completeButton.disabled = false;
            
            completeButton.addEventListener("click", async () => {
                // Turvakontrollid
                if (!currentUser || !currentUser.uid) {
                    alert("User information not found. Please refresh the page.");
                    return;
                }
                
                // P√§ringupiirangu (rate limit) kontroll
                const now = Date.now();
                if (now - lastQuestCompletionTime < MIN_QUEST_COMPLETION_INTERVAL) {
                    alert("Please wait a moment before completing more quests.");
                    return;
                }
                
                const checkboxes = document.querySelectorAll('.mission-item input[type="checkbox"]:checked:not(:disabled)');
                if (checkboxes.length === 0) {
                    alert("Please select at least one mission to complete!");
                    return;
                }
                
                // Check number of selected missions
                if (checkboxes.length > 10) {
                    alert("You can only complete up to 10 quests at once.");
                    return;
                }
                
                completeButton.disabled = true;
                completeButton.textContent = "Processing...";
                lastQuestCompletionTime = now;
                
                try {
                    const profileResult = await getUserProfile(currentUser.uid);
                    if (!profileResult || !profileResult.success) {
                        throw new Error("Error loading profile: " + (profileResult?.error || "Unknown error"));
                    }
                    
                    const profile = profileResult.data;
                    currentProfileData = profile;
                    if (!profile || typeof profile !== 'object') {
                        throw new Error("Invalid profile data");
                    }
                    
                    // Replay mode'da: Kontrollib, et valitud questid pole juba t√§na tehtud
                    const allQuestsCompleted = profile.allQuestsCompleted || false;
                    const dailyCompletedQuests = profile.dailyQuestsCompleted || [];
                    
                    if (allQuestsCompleted) {
                        const selectedQuestIds = Array.from(checkboxes).map(cb => {
                            const missionItem = cb.closest('.mission-item');
                            return missionItem?.dataset?.questId;
                        }).filter(Boolean);
                        
                        const alreadyCompletedToday = selectedQuestIds.filter(questId => 
                            dailyCompletedQuests.includes(questId)
                        );
                        
                        if (alreadyCompletedToday.length > 0) {
                            completeButton.disabled = false;
                            completeButton.textContent = "Complete Selected Missions";
                            alert(`‚ö†Ô∏è These quests are already completed today:\n\n${alreadyCompletedToday.join(', ')}\n\nPlease wait for the next daily reset to complete them again.`);
                            return;
                        }
                    }
                    
                    // Check only daily limit (5 missions per day) - no other verification needed
                    const selectedQuestIds = [];
                    checkboxes.forEach(checkbox => {
                        if (!checkbox) return;
                        const missionItem = checkbox.closest('.mission-item');
                        if (missionItem) {
                        const questId = missionItem.dataset.questId;
                            if (questId && typeof questId === 'string') {
                                selectedQuestIds.push(questId);
                            }
                        }
                    });
                    
                    const uniqueQuestIds = [...new Set(selectedQuestIds)];
                    
                    if (uniqueQuestIds.length > 0) {
                        const warnings = await detectAbnormalPattern(profile, uniqueQuestIds);
                        
                        if (!Array.isArray(warnings)) {
                            console.error("detectAbnormalPattern returned invalid result");
                        }
                        
                        // Peatab kui p√§evalimiit on √ºletatud
                        const dailyLimitWarnings = warnings.filter(w => 
                            w && w.type && w.type === "daily_limit"
                        );
                    
                        if (dailyLimitWarnings.length > 0) {
                        completeButton.disabled = false;
                        completeButton.textContent = "Complete Selected Missions";
                            const errorMessages = dailyLimitWarnings.map(w => w.message || "Daily limit exceeded").join('\n\n');
                            alert(`‚ö†Ô∏è Daily Quest Limit\n\n${errorMessages}`);
                        return;
                    }
                    }
                    
                    // Split missions into groups with and without photos
                    const photoChecks = await Promise.all(
                        uniqueQuestIds.map(async questId => ({
                            questId,
                            requiresPhoto: await questRequiresPhoto(questId)
                        }))
                    );
                    const questsRequiringPhoto = photoChecks.filter(c => c.requiresPhoto).map(c => c.questId);
                    const questsWithoutPhoto = photoChecks.filter(c => !c.requiresPhoto).map(c => c.questId);
                    
                    const completionData = {
                        currentUser: currentUser,
                        profile: profile,
                        quests: quests,
                        checkboxes: checkboxes,
                        completeButton: completeButton
                    };
                    
                    // Complete missions without photo requirements directly
                    if (questsWithoutPhoto.length > 0) {
                        const reflectionsProvided = await ensureReflectionNotes(questsWithoutPhoto);
                        if (!reflectionsProvided) {
                            completeButton.disabled = false;
                            completeButton.textContent = "Complete Selected Missions";
                            return;
                        }
                        // M√§rgib kinnitatuks (fotot pole vaja)
                        questsWithoutPhoto.forEach(questId => {
                            verifiedPhotos[questId] = true;
                        });
                        await completeQuestsWithPhoto(questsWithoutPhoto, completionData, verifiedPhotos, questReflectionNotes);
                        questsWithoutPhoto.forEach(questId => {
                            delete questReflectionNotes[questId];
                        });
                        verifiedPhotos = {};
                    }
                    
                    if (questsRequiringPhoto.length > 0) {
                        showPhotoUploadModal(questsRequiringPhoto, completionData);
                    } else {
                        if (completeButton) {
                            completeButton.disabled = false;
                            completeButton.textContent = "Complete Selected Missions";
                        }
                    }
                } catch (error) {
                    console.error("Error in quest completion:", error);
                    const errorMessage = getErrorMessage(error);
                    alert(`Unable to complete quests:\n\n${errorMessage}`);
                    completeButton.disabled = false;
                    completeButton.textContent = "Complete Selected Missions";
                }
            });
            
            missionList.appendChild(completeButton);
        }

        let categoryChartInstance = null;
        let carbonChartInstance = null;

        const QUEST_ID_MAPPING = {
            "1": { 
                jsonIds: ["recycling_1", "cleanup_1"], 
                category: "recycling",
                categoryName: "Recycling",
                categoryIcon: "‚ôªÔ∏è",
                categoryColor: "#4CAF50"
            },
            "2": { 
                jsonIds: ["energy_1"], 
                category: "energy_saving",
                categoryName: "Energy Saving",
                categoryIcon: "üí°",
                categoryColor: "#FFC107"
            },
            "3": { 
                jsonIds: ["recycling_2"], 
                category: "recycling",
                categoryName: "Recycling",
                categoryIcon: "‚ôªÔ∏è",
                categoryColor: "#4CAF50"
            },
            "4": { 
                jsonIds: ["transportation_1"], 
                category: "transportation",
                categoryName: "Transportation",
                categoryIcon: "üö∂",
                categoryColor: "#2196F3"
            },
            "5": { 
                jsonIds: ["water_1"], 
                category: "water_saving",
                categoryName: "Water Saving",
                categoryIcon: "üíß",
                categoryColor: "#00BCD4"
            },
            "6": { 
                jsonIds: ["recycling_3", "cleanup_2"], 
                category: "cleanup_missions",
                categoryName: "Clean-Up",
                categoryIcon: "üßπ",
                categoryColor: "#9C27B0"
            },
            "7": { 
                jsonIds: ["recycling_4"], 
                category: "recycling",
                categoryName: "Recycling",
                categoryIcon: "‚ôªÔ∏è",
                categoryColor: "#4CAF50"
            },
            "8": { 
                jsonIds: ["water_2"], 
                category: "water_saving",
                categoryName: "Water Saving",
                categoryIcon: "üíß",
                categoryColor: "#00BCD4"
            },
            "9": { 
                jsonIds: ["recycling_5"], 
                category: "recycling",
                categoryName: "Recycling",
                categoryIcon: "‚ôªÔ∏è",
                categoryColor: "#4CAF50"
            },
            "10": { 
                jsonIds: ["energy_2"], 
                category: "energy_saving",
                categoryName: "Energy Saving",
                categoryIcon: "üí°",
                categoryColor: "#FFC107"
            },
            "11": { 
                jsonIds: ["energy_3"], 
                category: "energy_saving",
                categoryName: "Energy Saving",
                categoryIcon: "üí°",
                categoryColor: "#FFC107"
            },
            "12": { 
                jsonIds: ["gardening_1"], 
                category: "gardening",
                categoryName: "Gardening & Nature",
                categoryIcon: "üå±",
                categoryColor: "#66BB6A"
            },
            "13": { 
                jsonIds: ["transportation_2"], 
                category: "transportation",
                categoryName: "Transportation",
                categoryIcon: "üö∂",
                categoryColor: "#2196F3"
            },
            "14": { 
                jsonIds: ["sustainable_1"], 
                category: "sustainable_living",
                categoryName: "Sustainable Living",
                categoryIcon: "‚ôªÔ∏è",
                categoryColor: "#8BC34A"
            },
            "15": { 
                jsonIds: ["sustainable_2"], 
                category: "sustainable_living",
                categoryName: "Sustainable Living",
                categoryIcon: "‚ôªÔ∏è",
                categoryColor: "#8BC34A"
            },
            "16": { 
                jsonIds: ["energy_4"], 
                category: "energy_saving",
                categoryName: "Energy Saving",
                categoryIcon: "üí°",
                categoryColor: "#FFC107"
            },
            "17": { 
                jsonIds: ["sustainable_3"], 
                category: "sustainable_living",
                categoryName: "Sustainable Living",
                categoryIcon: "‚ôªÔ∏è",
                categoryColor: "#8BC34A"
            },
            "18": { 
                jsonIds: ["energy_5"], 
                category: "energy_saving",
                categoryName: "Energy Saving",
                categoryIcon: "üí°",
                categoryColor: "#FFC107"
            },
            "19": { 
                jsonIds: ["recycling_6"], 
                category: "recycling",
                categoryName: "Recycling",
                categoryIcon: "‚ôªÔ∏è",
                categoryColor: "#4CAF50"
            },
            "20": { 
                jsonIds: ["cleanup_3"], 
                category: "cleanup_missions",
                categoryName: "Clean-Up",
                categoryIcon: "üßπ",
                categoryColor: "#9C27B0"
            },
            "21": { 
                jsonIds: ["energy_6"], 
                category: "energy_saving",
                categoryName: "Energy Saving",
                categoryIcon: "üí°",
                categoryColor: "#FFC107"
            },
            "22": { 
                jsonIds: ["transportation_3"], 
                category: "transportation",
                categoryName: "Transportation",
                categoryIcon: "üö∂",
                categoryColor: "#2196F3"
            },
            "23": { 
                jsonIds: ["sustainable_4"], 
                category: "sustainable_living",
                categoryName: "Sustainable Living",
                categoryIcon: "‚ôªÔ∏è",
                categoryColor: "#8BC34A"
            },
            "24": { 
                jsonIds: ["energy_7"], 
                category: "energy_saving",
                categoryName: "Energy Saving",
                categoryIcon: "üí°",
                categoryColor: "#FFC107"
            },
            "25": { 
                jsonIds: ["gardening_2"], 
                category: "gardening",
                categoryName: "Gardening & Nature",
                categoryIcon: "üå±",
                categoryColor: "#66BB6A"
            },
            "26": { 
                jsonIds: ["recycling_7"], 
                category: "recycling",
                categoryName: "Recycling",
                categoryIcon: "‚ôªÔ∏è",
                categoryColor: "#4CAF50"
            },
            "27": { 
                jsonIds: ["recycling_8"], 
                category: "recycling",
                categoryName: "Recycling",
                categoryIcon: "‚ôªÔ∏è",
                categoryColor: "#4CAF50"
            },
            "28": { 
                jsonIds: ["energy_8"], 
                category: "energy_saving",
                categoryName: "Energy Saving",
                categoryIcon: "üí°",
                categoryColor: "#FFC107"
            },
            "29": { 
                jsonIds: ["energy_9"], 
                category: "energy_saving",
                categoryName: "Energy Saving",
                categoryIcon: "üí°",
                categoryColor: "#FFC107"
            },
            "30": { 
                jsonIds: ["transportation_4"], 
                category: "transportation",
                categoryName: "Transportation",
                categoryIcon: "üö∂",
                categoryColor: "#2196F3"
            },
            "31": { 
                jsonIds: ["water_3"], 
                category: "water_saving",
                categoryName: "Water Saving",
                categoryIcon: "üíß",
                categoryColor: "#00BCD4"
            },
            "32": { 
                jsonIds: ["cleanup_4"], 
                category: "cleanup_missions",
                categoryName: "Clean-Up",
                categoryIcon: "üßπ",
                categoryColor: "#9C27B0"
            },
            "33": { 
                jsonIds: ["gardening_3"], 
                category: "gardening",
                categoryName: "Gardening & Nature",
                categoryIcon: "üå±",
                categoryColor: "#66BB6A"
            },
            "34": { 
                jsonIds: ["sustainable_5"], 
                category: "sustainable_living",
                categoryName: "Sustainable Living",
                categoryIcon: "‚ôªÔ∏è",
                categoryColor: "#8BC34A"
            },
            "35": { 
                jsonIds: ["sustainable_6"], 
                category: "sustainable_living",
                categoryName: "Sustainable Living",
                categoryIcon: "‚ôªÔ∏è",
                categoryColor: "#8BC34A"
            }
        };

        // Laeb quests.json faili ja tagastab sisu turvaliselt.
        async function loadQuestsData() {
            try {
                const response = await fetch('../quests.json');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return await response.json();
            } catch (error) {
                console.error("Error loading quests.json:", error);
                return null;
            }
        }

        function mapCompletedQuestIds(completedQuestIds) {
            const mappedIds = new Set();
            completedQuestIds.forEach(id => {
                const mapped = QUEST_ID_MAPPING[id];
                if (mapped && mapped.jsonIds) {
                    mapped.jsonIds.forEach(mappedId => mappedIds.add(mappedId));
                }
            });
            return Array.from(mappedIds);
        }

        // V√µrdleb tehtud missioone koguarvuga, et tuvastada 100% edenemist.
        async function checkAllQuestsCompleted(completedQuestIds) {
            try {
                const questsData = await loadQuestsData();
                if (!questsData || !questsData.metadata) {
                    return { allCompleted: false, totalQuests: 0, completedCount: 0 };
                }

                const totalQuests = questsData.metadata.totalQuests || 0;
                const completedCount = completedQuestIds ? completedQuestIds.length : 0;
                const allCompleted = completedCount >= totalQuests && totalQuests > 0;

                return { allCompleted, totalQuests, completedCount };
            } catch (error) {
                console.error("Error checking all quests completion:", error);
                return { allCompleted: false, totalQuests: 0, completedCount: 0 };
            }
        }

        // Shows special card when user has completed all quests.
        async function showAllQuestsCompletedInfoCard(user = null) {
            if (document.getElementById('allQuestsCompletedCard')) {
                return;
            }

            const targetUser = user || currentUser;
            if (!targetUser) {
                console.error("No user provided to showAllQuestsCompletedInfoCard");
                return;
            }

            let completionCount = 0;
            try {
                const profileResult = await getUserProfile(targetUser.uid);
                if (profileResult.success) {
                    completionCount = profileResult.data.allQuestsCompletedCount || 0;
                }
            } catch (error) {
                console.error("Error loading completion count:", error);
            }

            const infoCard = document.createElement('div');
            infoCard.id = 'allQuestsCompletedCard';
            infoCard.style.cssText = `
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 20px;
                border-radius: 15px;
                margin: 20px 0;
                text-align: center;
                box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
            `;

            infoCard.innerHTML = `
                <div style="position: relative; display: flex; align-items: center; justify-content: center; gap: 15px; margin-bottom: 15px;">
                    <div class="replay-icon" style="font-size: 48px; position: relative;">üîÑ</div>
                    <div style="text-align: left;">
                        <h3 style="margin: 0; font-size: 22px; font-weight: 600; text-shadow: 0 2px 4px rgba(0,0,0,0.2);">Replay Mode Active!</h3>
                        <p style="margin: 5px 0 0 0; opacity: 0.95; font-size: 16px; font-weight: 600;">
                            ${completionCount} ${completionCount === 1 ? 'time' : 'times'} completed
                        </p>
                    </div>
                </div>
                <p style="margin: 10px 0; opacity: 0.95; font-size: 14px;">
                    Amazing work! You've completed all eco-friendly quests and earned the <strong>Master Eco Warrior</strong> badge! üåç‚ú®
                </p>
                <p style="margin: 15px 0 0 0; opacity: 0.9; font-size: 13px; font-style: italic;">
                    Keep playing to earn bonus rewards by repeating quests!
                </p>
            `;
            
            // lisab s√§delevad t√§hed
            const sparklesContainer = document.createElement('div');
            sparklesContainer.style.cssText = 'position: absolute; top: 0; left: 0; right: 0; bottom: 0; pointer-events: none; overflow: hidden; border-radius: 15px;';
            for (let i = 0; i < 5; i++) {
                const sparkle = document.createElement('div');
                sparkle.className = 'replay-sparkle';
                sparklesContainer.appendChild(sparkle);
            }
            infoCard.style.position = 'relative';
            infoCard.appendChild(sparklesContainer);

            const userStats = document.querySelector('.user-stats');
            if (userStats && userStats.parentNode) {
                userStats.parentNode.insertBefore(infoCard, userStats.nextSibling);
            } else {
                const dashboard = document.getElementById('dashboard');
                if (dashboard) {
                    dashboard.insertBefore(infoCard, dashboard.firstChild);
                }
            }
        }

        // n√§itab erilist animatsiooni replay mode avamisel
        function showReplayModeUnlockAnimation() {
            // loob tumeda tausta overlay
            const overlay = document.createElement('div');
            overlay.id = 'replayModeOverlay';
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.75);
                z-index: 9999;
                animation: fadeIn 0.4s ease-out;
            `;
            
            const animationContainer = document.createElement('div');
            animationContainer.id = 'replayModeUnlockAnimation';
            animationContainer.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                z-index: 10000;
                pointer-events: none;
                display: flex;
                align-items: center;
                justify-content: center;
            `;
            
            const celebrationText = document.createElement('div');
            celebrationText.style.cssText = `
                background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
                background-size: 200% 200%;
                color: white;
                padding: 50px 70px;
                border-radius: 25px;
                font-size: 32px;
                font-weight: 700;
                text-align: center;
                box-shadow: 0 15px 50px rgba(102, 126, 234, 0.6);
                animation: slideInReplay 0.8s cubic-bezier(0.34, 1.56, 0.64, 1), pulseReplay 2s ease-in-out infinite, gradientShift 3s ease infinite;
                text-shadow: 0 2px 10px rgba(0,0,0,0.3);
                position: relative;
                overflow: hidden;
            `;
            
            // lisab s√§delevad t√§hed taustale
            const sparkles = document.createElement('div');
            sparkles.style.cssText = 'position: absolute; top: 0; left: 0; right: 0; bottom: 0; pointer-events: none;';
            for (let i = 0; i < 8; i++) {
                const sparkle = document.createElement('div');
                sparkle.style.cssText = `
                    position: absolute;
                    width: 12px;
                    height: 12px;
                    background: #ffd700;
                    border-radius: 50%;
                    animation: sparkle 2s ease-in-out infinite;
                    animation-delay: ${i * 0.25}s;
                `;
                sparkle.style.top = `${Math.random() * 100}%`;
                sparkle.style.left = `${Math.random() * 100}%`;
                sparkles.appendChild(sparkle);
            }
            celebrationText.appendChild(sparkles);
            
            celebrationText.innerHTML += `
                <div style="font-size: 80px; margin-bottom: 25px; animation: rotateReplay 2s linear infinite; position: relative; z-index: 1;">üîÑ</div>
                <div style="font-size: 42px; margin-bottom: 15px; position: relative; z-index: 1; animation: slideInReplay 0.8s ease-out 0.2s both;">üéâ Replay Mode Unlocked! üéâ</div>
                <div style="font-size: 20px; opacity: 0.95; margin-top: 15px; position: relative; z-index: 1; animation: slideInReplay 0.8s ease-out 0.4s both;">Keep playing to earn bonus rewards!</div>
                <div style="font-size: 16px; opacity: 0.8; margin-top: 20px; position: relative; z-index: 1; animation: slideInReplay 0.8s ease-out 0.6s both;">‚ú® Repeat quests for up to 3x XP bonus! ‚ú®</div>
            `;
            
            animationContainer.appendChild(celebrationText);
            document.body.appendChild(overlay);
            document.body.appendChild(animationContainer);
            
            // eemaldab animatsiooni p√§rast 4 sekundit
            setTimeout(() => {
                celebrationText.style.animation = 'slideInReplay 0.6s ease-out reverse';
                overlay.style.animation = 'fadeIn 0.5s ease-out reverse';
                setTimeout(() => {
                    if (animationContainer.parentNode) {
                        animationContainer.parentNode.removeChild(animationContainer);
                    }
                    if (overlay.parentNode) {
                        overlay.parentNode.removeChild(overlay);
                    }
                }, 600);
            }, 4000);
        }

        async function showAllQuestsCompletedCelebration(user, bonusXP = 500, bonusEcoPoints = 250, profileData = null) {
            const modal = document.createElement('div');
            modal.className = 'celebration-modal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.8);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 10000;
                animation: fadeIn 0.3s ease-in;
            `;

            modal.innerHTML = `
                <div style="
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    padding: 40px;
                    border-radius: 20px;
                    text-align: center;
                    color: white;
                    max-width: 500px;
                    width: 90%;
                    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
                    animation: scaleIn 0.5s ease-out;
                ">
                    <div style="font-size: 80px; margin-bottom: 20px; animation: bounce 1s infinite;">üéâ</div>
                    <h2 style="font-size: 32px; margin-bottom: 15px; font-weight: 700;">ALL QUESTS COMPLETED!</h2>
                    <p style="font-size: 18px; margin-bottom: 25px; opacity: 0.95;">
                        Amazing work! You've completed all eco-friendly quests and become a true <strong>Eco Warrior</strong>! üåç‚ú®
                    </p>
                    <div style="
                        background: rgba(255, 255, 255, 0.2);
                        padding: 20px;
                        border-radius: 10px;
                        margin-bottom: 25px;
                    ">
                        <p style="font-size: 16px; margin: 10px 0;">
                            <strong>üèÜ Special Badge:</strong> Master Eco Warrior
                        </p>
                        <p style="font-size: 16px; margin: 10px 0;">
                            <strong>‚ú® Bonus XP:</strong> +${bonusXP} XP
                        </p>
                        <p style="font-size: 16px; margin: 10px 0;">
                            <strong>üí∞ Bonus EcoPoints:</strong> +${bonusEcoPoints} EcoPoints
                        </p>
                    </div>
                    <button id="closeCelebration" style="
                        background: white;
                        color: #667eea;
                        border: none;
                        padding: 15px 40px;
                        border-radius: 25px;
                        font-size: 16px;
                        font-weight: 600;
                        cursor: pointer;
                        transition: transform 0.2s;
                    " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                        Awesome! üéä
                    </button>
                </div>
            `;

            if (!document.getElementById('celebration-styles')) {
                const style = document.createElement('style');
                style.id = 'celebration-styles';
                style.textContent = `
                    @keyframes fadeIn {
                        from { opacity: 0; }
                        to { opacity: 1; }
                    }
                    @keyframes scaleIn {
                        from { transform: scale(0.8); opacity: 0; }
                        to { transform: scale(1); opacity: 1; }
                    }
                    @keyframes bounce {
                        0%, 100% { transform: translateY(0); }
                        50% { transform: translateY(-20px); }
                    }
                `;
                document.head.appendChild(style);
            }

            document.body.appendChild(modal);

            const closeBtn = document.getElementById('closeCelebration');
            closeBtn.addEventListener('click', () => {
                modal.style.animation = 'fadeOut 0.3s ease-out';
                setTimeout(() => {
                    document.body.removeChild(modal);
                }, 300);
            });

            try {
                let profile;
                if (profileData) {
                    profile = {
                        xp: profileData.currentXP || 0,
                        ecoPoints: profileData.currentEcoPoints || 0,
                        badges: profileData.currentBadges || [],
                        level: profileData.currentLevel || 1,
                        missionsCompleted: 0, // Vajadusel asendatakse profiili tegeliku v√§√§rtusega
                        allQuestsCompletedCount: profileData.allQuestsCompletedCount || 0
                    };
                } else {
                    const profileResult = await getUserProfile(user.uid);
                    if (!profileResult.success) {
                        throw new Error("Failed to load profile");
                    }
                    profile = profileResult.data;
                }
                
                const currentXP = profile.xp || 0;
                const currentEcoPoints = profile.ecoPoints || 0;
                const currentBadges = profile.badges || [];
                const currentLevel = profile.level || calculateLevel(currentXP);

                const masterBadge = "Master Eco Warrior";
                const updatedBadges = currentBadges.includes(masterBadge) 
                    ? currentBadges 
                    : [...currentBadges, masterBadge];

                const newXP = currentXP + bonusXP;
                const newLevel = calculateLevel(newXP);
                const newEcoPoints = currentEcoPoints + bonusEcoPoints;

                const currentAllQuestsCompletedCount = profile.allQuestsCompletedCount || 0;
                await updateUserProfile(user.uid, {
                    xp: newXP,
                    ecoPoints: newEcoPoints,
                    level: newLevel,
                    badges: updatedBadges,
                    allQuestsCompleted: true,
                    allQuestsCompletedDate: new Date().toISOString(),
                    allQuestsCompletedCount: currentAllQuestsCompletedCount === 0 ? 1 : currentAllQuestsCompletedCount
                });

                let missionsCompleted = profile.missionsCompleted || 0;
                let completedQuests = profile.completedQuests || [];
                if (!profileData) {
                    const profileResult = await getUserProfile(user.uid);
                    if (profileResult.success) {
                        missionsCompleted = profileResult.data.missionsCompleted || 0;
                        completedQuests = profileResult.data.completedQuests || [];
                    }
                }

                await updateUI(newXP, newLevel, missionsCompleted, newEcoPoints, user, currentLevel, completedQuests);
            } catch (error) {
                console.error("Error awarding bonus rewards:", error);
            }
        }

        async function calculateTotalCarbonReduction(completedQuestIds) {
            try {
                const questsData = await loadQuestsData();
                if (!questsData || !questsData.categories) {
                    return 0;
                }

                const mappedCompletedIds = mapCompletedQuestIds(completedQuestIds || []);
                let totalCarbon = 0;

                questsData.categories.forEach(category => {
                    if (!category || !category.quests) return;
                    
                    category.quests.forEach(quest => {
                        if (quest && mappedCompletedIds.includes(quest.id)) {
                            totalCarbon += quest.carbonFootprintReduction || 0;
                        }
                    });
                });

                return totalCarbon;
            } catch (error) {
                console.error("Error calculating total carbon reduction:", error);
                return 0;
            }
        }

        function calculateQuestProgress(questsData, completedQuestIds) {
            if (!questsData || !questsData.categories) {
                return null;
            }

            const mappedCompletedIds = mapCompletedQuestIds(completedQuestIds);

            const categoryStats = questsData.categories.map(category => {
                const totalQuests = category.quests.length;
                const completedQuests = category.quests.filter(quest => 
                    mappedCompletedIds.includes(quest.id)
                ).length;
                
                const totalCarbonReduction = category.quests.reduce((sum, quest) => {
                    if (mappedCompletedIds.includes(quest.id)) {
                        return sum + quest.carbonFootprintReduction;
                    }
                    return sum;
                }, 0);

                const maxCarbonReduction = category.quests.reduce((sum, quest) => 
                    sum + quest.carbonFootprintReduction, 0
                );

                return {
                    id: category.id,
                    name: category.name,  
                    icon: category.icon,
                    color: category.color,
                    badgeName: category.badgeName,
                    totalQuests,
                    completedQuests,
                    completionPercentage: totalQuests > 0 ? (completedQuests / totalQuests) * 100 : 0,
                    totalCarbonReduction,
                    maxCarbonReduction,
                    carbonPercentage: maxCarbonReduction > 0 ? (totalCarbonReduction / maxCarbonReduction) * 100 : 0
                };
            });

            return categoryStats;
        }

        function renderCategoryProgress(categoryStats) {
            const progressList = document.getElementById("categoryProgressList");
            if (!progressList || !categoryStats) return;

            progressList.innerHTML = "";

            categoryStats.forEach(category => {
                const categoryCard = document.createElement("div");
                categoryCard.className = "category-progress-card";
                categoryCard.style.borderLeft = `4px solid ${category.color}`;

                const isCompleted = category.completedQuests === category.totalQuests && category.totalQuests > 0;

                categoryCard.innerHTML = `
                    <div class="category-progress-header">
                        <div class="category-info">
                            <span class="category-icon">${category.icon}</span>
                            <div>
                                <h4>${category.name}</h4>
                                <p class="category-stats">${category.completedQuests} / ${category.totalQuests} quests completed</p>
                            </div>
                        </div>
                        ${isCompleted ? `<span class="category-badge">üèÜ ${category.badgeName}</span>` : ''}
                    </div>
                    <div class="progress-bar-container">
                        <div class="progress-bar" style="background: ${category.color}20;">
                            <div class="progress-fill" style="width: ${category.completionPercentage}%; background: ${category.color};"></div>
                        </div>
                        <span class="progress-text">${category.completionPercentage.toFixed(0)}%</span>
                    </div>
                    <div class="carbon-info">
                        <span>Carbon Reduced: <strong>${category.totalCarbonReduction.toFixed(1)} / ${category.maxCarbonReduction.toFixed(1)} kg CO‚ÇÇ</strong></span>
                    </div>
                `;

                progressList.appendChild(categoryCard);
            });
        }

        let resizeTimeout;
        function handleChartResize() {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                if (categoryChartInstance) {
                    categoryChartInstance.resize();
                }
                if (carbonChartInstance) {
                    carbonChartInstance.resize();
                }
            }, 250);
        }

        window.addEventListener('resize', handleChartResize);

        function renderCharts(categoryStats) {
            if (!categoryStats || categoryStats.length === 0) {
                const categoryWrapper = document.querySelector('#categoryChart')?.parentElement;
                const carbonWrapper = document.querySelector('#carbonChart')?.parentElement;
                if (categoryWrapper) {
                    categoryWrapper.innerHTML = '<h3>Category Completion</h3><p style="text-align: center; color: #999; padding: 40px;">No quest data available</p>';
                }
                if (carbonWrapper) {
                    carbonWrapper.innerHTML = '<h3>Carbon Footprint Reduction</h3><p style="text-align: center; color: #999; padding: 40px;">No quest data available</p>';
                }
                return;
            }

            if (categoryChartInstance) {
                categoryChartInstance.destroy();
                categoryChartInstance = null;
            }
            if (carbonChartInstance) {
                carbonChartInstance.destroy();
                carbonChartInstance = null;
            }

            let categoryCtx = document.getElementById("categoryChart");
            let carbonCtx = document.getElementById("carbonChart");

            if (!categoryCtx) {
                const categoryWrapper = document.querySelector('.chart-wrapper:first-of-type');
                if (categoryWrapper) {
                    categoryWrapper.innerHTML = '<h3>Category Completion</h3><canvas id="categoryChart"></canvas>';
                    categoryCtx = document.getElementById("categoryChart");
                }
            }

            if (!carbonCtx) {
                const carbonWrapper = document.querySelector('.chart-wrapper:last-of-type');
                if (carbonWrapper) {
                    carbonWrapper.innerHTML = '<h3>Carbon Footprint Reduction</h3><canvas id="carbonChart"></canvas>';
                    carbonCtx = document.getElementById("carbonChart");
                }
            }

            if (!categoryCtx || !carbonCtx) {
                console.error("Chart canvas elements not found");
                return;
            }

            categoryChartInstance = new Chart(categoryCtx, {
                type: 'doughnut',
                data: {
                    labels: categoryStats.map(cat => `${cat.icon} ${cat.name}`),
                    datasets: [{
                        data: categoryStats.map(cat => cat.completedQuests),
                        backgroundColor: categoryStats.map(cat => cat.color),
                        borderWidth: 3,
                        borderColor: '#fff'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    aspectRatio: window.innerWidth < 640 ? 1.2 : (window.innerWidth < 1024 ? 1.4 : 1.5),
                    layout: {
                        padding: {
                            top: window.innerWidth < 640 ? 8 : 10,
                            bottom: window.innerWidth < 640 ? 8 : 10,
                            left: window.innerWidth < 640 ? 5 : 10,
                            right: window.innerWidth < 640 ? 5 : 10
                        }
                    },
                    onResize: function(chart, size) {
                        if (size.height < 200) {
                            chart.options.aspectRatio = 1.2;
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'bottom',
                            labels: {
                                padding: window.innerWidth < 640 ? 8 : 15,
                                font: {
                                    size: window.innerWidth < 640 ? 10 : 11,
                                    family: 'Inter, sans-serif'
                                },
                                usePointStyle: true,
                                pointStyle: 'circle',
                                boxWidth: window.innerWidth < 640 ? 6 : 8,
                                boxHeight: window.innerWidth < 640 ? 6 : 8
                            }
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            padding: 12,
                            titleFont: {
                                size: 14,
                                weight: 'bold'
                            },
                            bodyFont: {
                                size: 12
                            },
                            callbacks: {
                                label: function(context) {
                                    const label = context.label.replace(/^\S+\s/, '') || '';
                                    const value = context.parsed || 0;
                                    const category = categoryStats[context.dataIndex];
                                    return [
                                        `${label}`,
                                        `Completed: ${value} / ${category.totalQuests} quests`,
                                        `Progress: ${category.completionPercentage.toFixed(0)}%`
                                    ];
                                }
                            }
                        }
                    }
                }
            });

            const totalCarbonReduced = categoryStats.reduce((sum, cat) => sum + cat.totalCarbonReduction, 0);
            const totalCarbonPotential = categoryStats.reduce((sum, cat) => sum + cat.maxCarbonReduction, 0);
            
            carbonChartInstance = new Chart(carbonCtx, {
                type: 'bar',
                data: {
                    labels: categoryStats.map(cat => `${cat.icon}\n${cat.name}`),
                    datasets: [
                        {
                            label: 'Carbon Reduced',
                            data: categoryStats.map(cat => cat.totalCarbonReduction),
                            backgroundColor: categoryStats.map(cat => cat.color),
                            borderColor: categoryStats.map(cat => cat.color),
                            borderWidth: 2,
                            borderRadius: 8,
                            borderSkipped: false,
                        },
                        {
                            label: 'Remaining Potential',
                            data: categoryStats.map(cat => cat.maxCarbonReduction - cat.totalCarbonReduction),
                            backgroundColor: categoryStats.map(cat => cat.color + '40'),
                            borderColor: categoryStats.map(cat => cat.color),
                            borderWidth: 1,
                            borderRadius: {
                                topLeft: 0,
                                topRight: 0,
                                bottomLeft: 8,
                                bottomRight: 8
                            },
                            borderSkipped: false,
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    aspectRatio: window.innerWidth < 640 ? 1.3 : (window.innerWidth < 1024 ? 1.5 : 1.6),
                    layout: {
                        padding: {
                            top: window.innerWidth < 640 ? 5 : 10,
                            bottom: window.innerWidth < 640 ? 5 : 10,
                            left: window.innerWidth < 640 ? 5 : 10,
                            right: window.innerWidth < 640 ? 5 : 10
                        }
                    },
                    onResize: function(chart, size) {
                        if (size.height < 200) {
                            chart.options.aspectRatio = 1.3;
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            stacked: true,
                            title: {
                                display: true,
                                text: window.innerWidth < 640 ? 'CO‚ÇÇ Reduced (kg)' : 'Carbon Footprint Reduction (kg CO‚ÇÇ)',
                                font: {
                                    size: window.innerWidth < 640 ? 11 : 13,
                                    weight: 'bold'
                                },
                                color: '#424242',
                                padding: { top: window.innerWidth < 640 ? 5 : 10, bottom: window.innerWidth < 640 ? 5 : 10 }
                            },
                            ticks: {
                                font: {
                                    size: window.innerWidth < 640 ? 9 : 11
                                },
                                callback: function(value) {
                                    return value.toFixed(window.innerWidth < 640 ? 0 : 1);
                                },
                                maxTicksLimit: window.innerWidth < 640 ? 5 : 8
                            },
                            grid: {
                                color: 'rgba(0, 0, 0, 0.08)',
                                drawBorder: false
                            }
                        },
                        x: {
                            stacked: true,
                            ticks: {
                                font: {
                                    size: window.innerWidth < 640 ? 9 : 11,
                                    weight: '500'
                                },
                                maxRotation: window.innerWidth < 640 ? 45 : 0,
                                minRotation: window.innerWidth < 640 ? 45 : 0
                            },
                            grid: {
                                display: false
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'top',
                            labels: {
                                padding: window.innerWidth < 640 ? 10 : 18,
                                font: {
                                    size: window.innerWidth < 640 ? 10 : 12,
                                    family: 'Inter, sans-serif',
                                    weight: '500'
                                },
                                usePointStyle: true,
                                pointStyle: 'circle',
                                boxWidth: window.innerWidth < 640 ? 6 : 8,
                                boxHeight: window.innerWidth < 640 ? 6 : 8
                            }
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.85)',
                            padding: 14,
                            titleFont: {
                                size: 14,
                                weight: 'bold',
                                family: 'Inter, sans-serif'
                            },
                            bodyFont: {
                                size: 12,
                                family: 'Inter, sans-serif'
                            },
                            borderColor: 'rgba(255, 255, 255, 0.1)',
                            borderWidth: 1,
                            cornerRadius: 8,
                            displayColors: true,
                            callbacks: {
                                title: function(context) {
                                    return categoryStats[context[0].dataIndex].name;
                                },
                                label: function(context) {
                                    const label = context.dataset.label || '';
                                    const value = context.parsed.y.toFixed(2);
                                    const category = categoryStats[context.dataIndex];
                                    
                                    if (context.datasetIndex === 0) {
                                        const percentage = category.carbonPercentage.toFixed(0);
                                        return [
                                            `${label}: ${value} kg CO‚ÇÇ`,
                                            `Progress: ${percentage}% of potential`,
                                            `${category.completedQuests}/${category.totalQuests} quests completed`
                                        ];
                                    } else {
                                        return [
                                            `${label}: ${value} kg CO‚ÇÇ`,
                                            `Complete remaining quests to unlock`
                                        ];
                                    }
                                },
                                footer: function(tooltipItems) {
                                    if (tooltipItems.length > 0) {
                                        const category = categoryStats[tooltipItems[0].dataIndex];
                                        if (category.completedQuests === category.totalQuests && category.totalQuests > 0) {
                                            return `üèÜ ${category.badgeName} Badge Unlocked!`;
                                        } else if (category.totalQuests > 0) {
                                            return `Next: ${category.badgeName} (${category.totalQuests - category.completedQuests} quests left)`;
                                        }
                                    }
                                    return '';
                                }
                            }
                        }
                    },
                    animation: {
                        duration: 1000,
                        easing: 'easeOutQuart'
                    }
                }
            });
        }

        async function updateQuestCharts(completedQuestIds) {
            try {
                if (typeof Chart === 'undefined') {
                    console.error("Chart.js is not loaded");
                    return;
                }

                const questsData = await loadQuestsData();
                if (!questsData) {
                    const progressList = document.getElementById("categoryProgressList");
                    if (progressList) {
                        progressList.innerHTML = '<p style="text-align: center; color: #999; padding: 20px;">Unable to load quest data. Please refresh the page.</p>';
                    }
                    return;
                }

                const categoryStats = calculateQuestProgress(questsData, completedQuestIds || []);
                if (!categoryStats || categoryStats.length === 0) {
                    return;
                }

                const categoryCtx = document.getElementById("categoryChart");
                const carbonCtx = document.getElementById("carbonChart");
                
                if (!categoryCtx || !carbonCtx) {
                    setTimeout(() => updateQuestCharts(completedQuestIds), 200);
                    return;
                }

                renderCharts(categoryStats);
                renderCategoryProgress(categoryStats);
            } catch (error) {
                console.error("Error updating quest charts:", error);
            }
        }

        async function updateUI(xp, level, missionsCompleted, ecoPoints, user = null, oldLevel = null, completedQuests = null) {
            const userXPElement = document.getElementById("userXP");
            const ecoPointsElement = document.getElementById("ecoPoints");
            
            if (userXPElement) userXPElement.textContent = xp || 0;
            
            const progress = getXPProgress(xp || 0, level || 1);
            const progressFill = document.getElementById("levelProgressFill");
            const progressCurrent = document.getElementById("levelProgressCurrent");
            const progressNext = document.getElementById("levelProgressNext");
            
            if (progressFill) {
                const percentage = Math.min(100, Math.max(0, progress.percentage));
                progressFill.style.width = `${percentage}%`;
                const progressBar = progressFill.closest('.level-progress-bar');
                if (progressBar) {
                    progressBar.setAttribute('aria-valuenow', Math.round(percentage));
                }
            }
            if (progressCurrent) {
                progressCurrent.textContent = progress.current;
            }
            if (progressNext) {
                progressNext.textContent = progress.required;
            }
            
            if (ecoPointsElement) ecoPointsElement.textContent = ecoPoints || 0;
            
            if (completedQuests && Array.isArray(completedQuests)) {
                const totalCarbon = await calculateTotalCarbonReduction(completedQuests);
                const carbonElement = document.getElementById("totalCarbonReduced");
                if (carbonElement) {
                    carbonElement.textContent = totalCarbon.toFixed(1);
                }
            }
            
            const badgeElement = document.getElementById("userBadge");
            if (badgeElement) {
                displayBadge(badgeElement, level || 1, false);
            }
            
            displayBadgeShowcase(level || 1, false);
            
            if (user && oldLevel && level > oldLevel) {
                checkAndUnlockBadge(user, oldLevel, level);
            }
        }

        let currentUser = null;
        
        initializeReflectionModal();
        
        requireAuth().then(async (user) => {
            currentUser = user;
            
            // Kontrolli koorumisi ja n√§ita animatsioone enne muude andmete laadimist
            try {
                const { checkAndProcessHatchings, showHatchingAnimationsSequentially } = await import("../js/hatching-utils.js");
                const hatchingResult = await checkAndProcessHatchings(user.uid);
                if (hatchingResult.hasNewHatchings && hatchingResult.newAnimals.length > 0) {
                    // Peida dashboard sisu animatsioonide ajal
                    const dashboard = document.getElementById("dashboard");
                    if (dashboard) {
                        dashboard.style.opacity = "0";
                        dashboard.style.pointerEvents = "none";
                    }
                    
                    // N√§ita animatsioonid j√§rjestikku enne muude andmete laadimist
                    await showHatchingAnimationsSequentially(hatchingResult.newAnimals);
                    
                    // N√§ita dashboard sisu p√§rast animatsioone
                    if (dashboard) {
                        dashboard.style.opacity = "1";
                        dashboard.style.pointerEvents = "auto";
                        dashboard.style.transition = "opacity 0.5s ease-in";
                    }
                }
            } catch (error) {
                console.error("Error checking hatchings on login:", error);
            }
            
            try {
                const profileResult = await getUserProfile(user.uid);
                
                if (profileResult.success) {
                    const profile = profileResult.data;
                    const displayName = profile.displayName || user.email.split("@")[0];
                    const xp = profile.xp || 0;
                    const ecoPoints = profile.ecoPoints || calculateEcoPoints(xp, profile.level || 1, (profile.badges || []).length);
                    const missionsCompleted = profile.missionsCompleted || 0;
                    
                    const calculatedLevel = calculateLevel(xp);
                    const storedLevel = profile.level;
                    const level = calculatedLevel;
                    const completedQuests = profile.completedQuests || [];
                    
                    const userDisplayNameElement = document.getElementById("userDisplayName");
                    const userEmailElement = document.getElementById("userEmail");
                    const userLevelElement = document.getElementById("userLevel");
                    if (userDisplayNameElement) userDisplayNameElement.textContent = displayName || "User";
                    if (userEmailElement) userEmailElement.textContent = user.email || "Unknown";
                    if (userLevelElement) userLevelElement.textContent = level || 1;
                    
                    const badgeElement = document.getElementById("userBadge");
                    if (badgeElement) {
                        const expectedBadge = getBadgeNameForLevel(level);
                        const activeBadge = profile.activeBadge;
                        
                        displayBadge(badgeElement, level, false);
                        displayBadgeShowcase(level, false);
                        
                        const updates = {};
                        if (storedLevel !== calculatedLevel) {
                            updates.level = calculatedLevel;
                        }
                        if (activeBadge !== expectedBadge) {
                            updates.activeBadge = expectedBadge;
                            updates.badges = [...new Set([...(profile.badges || []), expectedBadge])];
                        }
                        if (!profile.ecoPoints || profile.ecoPoints !== ecoPoints) {
                            updates.ecoPoints = ecoPoints;
                        }
                        if (!profile.xp || profile.xp !== xp) {
                            updates.xp = xp;
                        }
                        
                        if (Object.keys(updates).length > 0) {
                            await updateUserProfile(user.uid, updates);
                        }
                    }
                    
                    await updateUI(xp, level, missionsCompleted, ecoPoints, user, null, completedQuests);
                    
                    const allQuestsCheck = await checkAllQuestsCompleted(completedQuests);
                    if (allQuestsCheck.allCompleted && profile.allQuestsCompleted) {
                        await showAllQuestsCompletedInfoCard(user);
                        // kui replay mode on juba aktiivne, n√§itab ka animatsiooni (kui see on esimene kord kui leht laetakse)
                        const replayCard = document.getElementById('allQuestsCompletedCard');
                        if (replayCard && !replayCard.classList.contains('animated')) {
                            replayCard.classList.add('animated');
                            // lisab v√§ikese animatsiooni kaardile
                            replayCard.style.animation = 'slideInReplay 0.6s ease-out, pulseReplay 2s ease-in-out infinite, gradientShift 3s ease infinite';
                        }
                    }
                    
                    setTimeout(async () => {
                        await updateQuestCharts(completedQuests);
                    }, 300);
                    
                    const allQuests = await loadQuests();
                    const missionListElement = document.getElementById("missionList");
                    if (allQuests.length === 0) {
                        if (missionListElement) {
                            missionListElement.innerHTML = "<p style='color: #999; text-align: center; padding: 20px;'>No missions available. Please check quests.md file.</p>";
                        }
                    } else {
                        try {
                        const dailyQuestsData = await loadUserDailyQuests(user, allQuests, completedQuests);
                        window.currentQuests = dailyQuestsData.quests;
                        await renderQuests(
                            dailyQuestsData.quests, 
                            user, 
                            completedQuests, 
                            dailyQuestsData.dailyCompleted || []
                        );
                        } catch (error) {
                            console.error('Error loading/rendering quests:', error);
                            if (missionListElement) {
                                missionListElement.innerHTML = `<p style='color: #d32f2f; text-align: center; padding: 20px;'>Error loading quests: ${error.message}</p>`;
                            }
                        }
                    }
                    
                } else {
                    const defaultDisplayName = user.email ? user.email.split("@")[0] : "User";
                    const currentTimestamp = new Date().toISOString();
                    
                    try {
                        // Kasutab setDoc'i uue profiili loomiseks (updateDoc toimib ainult olemasoleval dokil)
                        await setDoc(doc(db, "users", user.uid), {
                            email: user.email,
                            displayName: defaultDisplayName,
                            xp: 0,
                            ecoPoints: 0,
                            level: 1,
                            badges: [],
                            missionsCompleted: 0,
                            completedQuests: [],
                            lastQuestResetTime: currentTimestamp,
                            currentDailyQuests: [],
                            dailyQuestsCompleted: [],
                            questCompletionCount: {},
                            dailyQuestCompletions: {},
                            lastQuestCompletionTime: null,
                            plants: [],
                            bestRank: null,
                            allQuestsCompleted: false,
                            allQuestsCompletedCount: 0,
                            allQuestsCompletedDate: null,
                            teamId: null,
                            teamRole: null,
                            teamStats: {
                                missionsCompleted: 0,
                                xpEarned: 0,
                                ecoEarned: 0,
                                approvalsGiven: 0
                            },
                            notificationPreferences: {
                                dailyReminderEnabled: true,
                                reminderHour: 9,
                                teamUpdates: true,
                                questTips: true
                            },
                            reminderMetadata: {
                                lastReminderDate: null,
                                pendingReminderId: null
                            },
                            insightSnapshots: [],
                            createdAt: currentTimestamp
                        });
                        
                        setTimeout(() => {
                            location.reload();
                        }, 500);
                        return;
                    } catch (createError) {
                        console.error('Error creating profile:', createError);
                        console.error('Error details:', {
                            code: createError.code,
                            message: createError.message,
                            stack: createError.stack
                        });
                        
                    const userDisplayNameElement = document.getElementById("userDisplayName");
                    const userEmailElement = document.getElementById("userEmail");
                    const missionListElement = document.getElementById("missionList");
                    
                    if (userDisplayNameElement) {
                        userDisplayNameElement.textContent = user.email ? user.email.split("@")[0] : "User";
                    }
                    if (userEmailElement) {
                        userEmailElement.textContent = user.email || "Unknown";
                    }
                    if (missionListElement) {
                            let errorMsg = "Error creating profile. ";
                            if (createError.code === 'permission-denied') {
                                errorMsg += "Please check Firebase Firestore rules. Make sure 'allow create' is enabled for users collection.";
                            } else {
                                errorMsg += createError.message || 'Unknown error';
                            }
                            missionListElement.innerHTML = `<p style='color: #d32f2f; text-align: center; padding: 20px;'>${errorMsg}</p>`;
                        }
                    }
                }
            } catch (error) {
                console.error("Error loading dashboard:", error);
                console.error("Error details:", {
                    message: error.message,
                    code: error.code,
                    stack: error.stack,
                    name: error.name
                });
                
                const missionListElement = document.getElementById("missionList");
                const userDisplayNameElement = document.getElementById("userDisplayName");
                const userEmailElement = document.getElementById("userEmail");
                
                let errorMessage = "Error loading data. ";
                let userFriendlyMessage = "";
                
                // kontrollib konkreetseid veat√º√ºpe ja annab kasutajas√µbraliku vastuse
                if (error.code === 'permission-denied') {
                    // see v√µib t√§hendada, et Firestore reeglid on valed
                    userFriendlyMessage = "Permission denied. Please check Firebase Firestore rules.";
                } else if (error.code === 'unavailable') {
                    // teenus on ajutiselt k√§ttesaamatu
                    userFriendlyMessage = "Service temporarily unavailable. Please try again in a moment.";
                } else if (error.message) {
                    userFriendlyMessage = error.message;
                } else {
                    // tundmatu viga, logib konsooli
                    userFriendlyMessage = "Unknown error. Please check console for details.";
                }
                
                errorMessage += userFriendlyMessage;
                
                if (missionListElement) {
                    missionListElement.innerHTML = `
                        <div style='color: #d32f2f; text-align: center; padding: 20px;'>
                            <p style='margin-bottom: 10px;'><strong>${errorMessage}</strong></p>
                            <p style='font-size: 14px; margin-bottom: 10px;'>Please try:</p>
                            <ul style='text-align: left; display: inline-block; font-size: 14px;'>
                                <li>Check your internet connection</li>
                                <li>Refresh the page (F5 or Ctrl+R)</li>
                                <li>Check browser console (F12) for details</li>
                            </ul>
                            <button onclick='location.reload()' style='margin-top: 15px; padding: 10px 20px; background: var(--color-primary); color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 14px; font-weight: 600;'>Refresh Page</button>
                        </div>
                    `;
                }
                if (userDisplayNameElement) {
                    userDisplayNameElement.textContent = "Error";
                }
                if (userEmailElement) {
                    userEmailElement.textContent = "Unable to load";
                }
                
                alert(`Error loading dashboard:\n\n${userFriendlyMessage}\n\nPlease check the browser console (F12) for more details.`);
            }
        }).catch((error) => {
            console.error("Auth error:", error);
            window.location.href = "login.html";
        });

        const logoutButton = document.getElementById("logoutButton");
        if (logoutButton) {
            logoutButton.addEventListener("click", async () => {
                stopCountdown();
                try {
                    const result = await logOut();
                    if (result.success) {
                        window.location.href = "login.html";
                    } else {
                        const errorMessage = getErrorMessage(result.error);
                        alert(`Logout failed: ${errorMessage}`);
                    }
                } catch (error) {
                    console.error("Logout error:", error);
                    const errorMessage = getErrorMessage(error);
                    alert(`An error occurred during logout: ${errorMessage}`);
                }
            });
        }

        const mobileMenuToggle = document.getElementById("mobileMenuToggle");
        const mobileMenu = document.getElementById("mobileMenu");
        const logoutButtonMobile = document.getElementById("logoutButtonMobile");

        if (mobileMenuToggle && mobileMenu) {
            mobileMenuToggle.addEventListener("click", () => {
                const isActive = mobileMenu.classList.contains("active");
                mobileMenu.classList.toggle("active");
                mobileMenuToggle.classList.toggle("active");
                mobileMenuToggle.setAttribute("aria-expanded", !isActive);
                
                if (!isActive) {
                    document.body.style.overflow = "hidden";
                } else {
                    document.body.style.overflow = "";
                }
            });

            const menuLinks = mobileMenu.querySelectorAll("a");
            menuLinks.forEach(link => {
                link.addEventListener("click", () => {
                    mobileMenu.classList.remove("active");
                    mobileMenuToggle.classList.remove("active");
                    mobileMenuToggle.setAttribute("aria-expanded", "false");
                    document.body.style.overflow = "";
                });
            });

            document.addEventListener("click", (e) => {
                if (mobileMenu.classList.contains("active") && 
                    !mobileMenu.contains(e.target) && 
                    !mobileMenuToggle.contains(e.target)) {
                    mobileMenu.classList.remove("active");
                    mobileMenuToggle.classList.remove("active");
                    mobileMenuToggle.setAttribute("aria-expanded", "false");
                    document.body.style.overflow = "";
                }
            });
        }

        if (logoutButtonMobile) {
            logoutButtonMobile.addEventListener("click", async () => {
                stopCountdown();
                try {
                    const result = await logOut();
                    if (result.success) {
                        window.location.href = "login.html";
                    } else {
                        const errorMessage = getErrorMessage(result.error);
                        alert(`Logout failed: ${errorMessage}`);
                    }
                } catch (error) {
                    console.error("Logout error:", error);
                    const errorMessage = getErrorMessage(error);
                    alert(`An error occurred during logout: ${errorMessage}`);
                }
            });
        }

        window.addEventListener("beforeunload", () => {
            stopCountdown();
            if (categoryChartInstance) {
                categoryChartInstance.destroy();
                categoryChartInstance = null;
            }
            if (carbonChartInstance) {
                carbonChartInstance.destroy();
                carbonChartInstance = null;
            }
        });
        
    </script>
</body>
</html>